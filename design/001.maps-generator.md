# Design Document: Maps Generator

**Document ID**: 001  
**Created**: 2025-12-18  
**Status**: Draft  
**Author**: Civilization Development Team

## Overview

This document outlines the design for the map generation system for the Civilization game. The map generator is responsible for creating the game world, including terrain topology, plot boundaries, neighbor relationships, and various geographic attributes that will influence gameplay.

## Objectives

- Generate irregularly-shaped plots (parcels) that form the game world
- Establish and maintain neighbor relationships between adjacent plots
- Support configurable map generation parameters
- Enable spherical projection with edge wrapping (simulating a planet)
- Provide extensible attribute system for plots
- Support dynamic updates and additions of plot attributes

## Core Requirements

### 1. Irregular Plot Generation

**Requirement**: Plots must be irregularly shaped rather than uniform grids.

**Rationale**: Irregular plots create a more organic and realistic world map, avoiding the artificial appearance of square or hexagonal grids while providing strategic variety.

**Approach**: Use Voronoi diagram generation
- Start with randomly distributed seed points across the map space
- Generate Voronoi cells using these points as centers
- Each Voronoi cell becomes a plot
- Plots naturally have irregular shapes and varying sizes
- Number of seed points determines the granularity of the map

### 2. Neighbor Relationships

**Requirement**: Each plot must maintain references to its neighboring plots.

**Key Properties**:
- Neighbors are plots that share a border edge
- Neighbor relationships are bidirectional
- Relationships must be maintained during generation and any subsequent modifications
- Used for:
  - Movement calculations
  - Resource spread
  - Cultural/political boundaries
  - Combat mechanics
  - Trade routes

**Data Structure**:
```
Plot {
  id: unique identifier
  neighbors: []PlotID  // List of adjacent plot IDs
  center: Point        // Geographic center
  vertices: []Point    // Polygon vertices defining the plot boundary
  edges: []Edge        // Edges with information about shared borders
}
```

### 3. Configurable Map Generation

The map generator must support various configuration options to create different map types and gameplay scenarios.

#### 3.1 Spherical Projection Configuration

**Requirement**: Support projection of a sphere onto a 2D plane with appropriate edge wrapping.

**Configuration Options**:

```
ProjectionConfig {
  type: ProjectionType  // FLAT, CYLINDRICAL, SPHERICAL
  wrapHorizontal: bool  // Connect left and right edges
  wrapVertical: bool    // Connect top and bottom edges
  poleScaling: float    // Size multiplier for polar regions (top/bottom)
}

ProjectionType enum:
  - FLAT: Standard flat map, no wrapping
  - CYLINDRICAL: Horizontal wrapping (like Mercator), top/bottom are boundaries
  - SPHERICAL: Full sphere wrapping on both axes
```

**Pole Scaling**:
- When projecting a sphere to a plane, polar regions appear stretched
- `poleScaling` parameter controls size increase of plots near top/bottom edges
- Value of 1.0 = no scaling, values > 1.0 increase plot size toward poles
- Simulates the actual geographic distortion on real planet maps

**Edge Wrapping Implementation**:
- Plots at edges are generated with neighbor relationships that cross boundaries
- When `wrapHorizontal = true`: rightmost plots neighbor leftmost plots
- When `wrapVertical = true`: topmost plots neighbor bottommost plots
- Special handling for corner plots when both wrapping modes are enabled

#### 3.2 Ocean Percentage Configuration

**Requirement**: Ability to specify the percentage of ocean vs land area.

**Configuration**:
```
TerrainConfig {
  oceanPercentage: float  // 0.0 to 1.0, target percentage of ocean
  continentCount: int     // Number of major landmasses
  islandFrequency: float  // Probability of small islands (0.0 to 1.0)
  coastalRoughness: float // How jagged coastlines are (0.0 to 1.0)
}
```

**Generation Approach**:
1. Start with all plots as ocean
2. Select seed plots for continents based on `continentCount`
3. Grow landmasses from seeds using iterative expansion
4. Stop when target `oceanPercentage` is reached
5. Add islands based on `islandFrequency`
6. Adjust coastline based on `coastalRoughness` (fractal-like refinement)

### 4. Extensible Plot Attributes

**Requirement**: Plots must support a wide range of attributes that can be dynamically updated and extended.

**Core Attributes**:

```
PlotAttributes {
  // Terrain & Geography
  terrain: TerrainType      // OCEAN, GRASSLAND, DESERT, FOREST, etc.
  altitude: float           // Meters above sea level (can be negative for ocean floor)
  temperature: float        // In Celsius, affected by latitude and altitude
  humidity: float           // 0.0 to 1.0, affects vegetation and weather
  
  // Resources
  resources: []Resource     // List of available resources
  fertility: float          // Agricultural potential (0.0 to 1.0)
  
  // Dynamic Attributes
  ownership: PlayerID       // Which player/nation controls this plot
  population: int           // Current population
  development: float        // Infrastructure level (0.0 to 1.0)
  culture: CultureID        // Dominant culture
  
  // Extended Attributes (for future expansion)
  customAttributes: map[string]interface{}  // Key-value store for dynamic attributes
}

Resource {
  type: ResourceType   // IRON, HORSES, OIL, WHEAT, etc.
  abundance: float     // How much is available (0.0 to 1.0)
  discovered: bool     // Whether it's been discovered by any player
}

TerrainType enum:
  OCEAN, COAST, GRASSLAND, PLAINS, DESERT, TUNDRA,
  FOREST, JUNGLE, MOUNTAIN, HILL, SWAMP, ICE
```

**Extensibility Design**:
- Base attributes are strongly typed for performance
- `customAttributes` map allows runtime addition of new properties
- Attributes can be updated through game events, player actions, or simulation
- Support for attribute queries and filtering (e.g., "find all plots with fertility > 0.7")

## Technical Approach

### Algorithm Selection

**Voronoi Diagram Generation**:
- Use Fortune's Algorithm or Bowyer-Watson algorithm for efficiency
- Time complexity: O(n log n) where n is the number of plots
- Lloyd's relaxation can be applied to make plots more uniform if desired

**Delaunay Triangulation**:
- Generate Delaunay triangulation as dual graph to Voronoi diagram
- Useful for pathfinding and distance calculations
- Establishes the foundation for neighbor relationships

### Generation Pipeline

```
1. Configuration Phase
   ├─ Load/parse configuration parameters
   ├─ Validate parameters
   └─ Initialize random seed for reproducibility

2. Seed Generation Phase
   ├─ Generate random seed points based on target plot count
   ├─ Apply projection scaling (for spherical maps)
   └─ Optional: Apply Lloyd's relaxation for uniformity

3. Voronoi Generation Phase
   ├─ Compute Voronoi diagram from seed points
   ├─ Generate plot boundaries
   └─ Calculate plot centers and vertices

4. Neighbor Resolution Phase
   ├─ Identify shared edges between plots
   ├─ Build neighbor adjacency lists
   └─ Handle edge wrapping for spherical projections

5. Terrain Generation Phase
   ├─ Initialize all plots as ocean
   ├─ Generate continents using seed expansion
   ├─ Apply coastline refinement
   └─ Assign terrain types based on rules

6. Attribute Assignment Phase
   ├─ Calculate altitude using noise functions
   ├─ Derive temperature from latitude and altitude
   ├─ Calculate humidity using precipitation models
   ├─ Place resources based on terrain and attributes
   └─ Initialize all dynamic attributes to defaults

7. Post-Processing Phase
   ├─ Validate map consistency
   ├─ Generate metadata (statistics, preview)
   └─ Serialize map data
```

### Data Structures

```go
// Core map structure
type Map struct {
    ID           string
    Width        float64
    Height       float64
    Config       MapConfig
    Plots        map[PlotID]*Plot
    PlotCount    int
    Projection   ProjectionConfig
    CreatedAt    time.Time
}

// Configuration
type MapConfig struct {
    // Size and resolution
    PlotCount        int
    Dimensions       Dimensions  // Width x Height
    
    // Projection settings
    Projection       ProjectionConfig
    
    // Terrain settings
    Terrain          TerrainConfig
    
    // Attribute settings
    ResourceDensity  float64
    ClimateVariance  float64
    
    // Generation settings
    RandomSeed       int64
    RelaxationSteps  int  // Lloyd's relaxation iterations
}

// Individual plot
type Plot struct {
    ID              PlotID
    Center          Point
    Vertices        []Point
    Neighbors       []PlotID
    Attributes      PlotAttributes
    
    // Cached calculations
    Area            float64
    Perimeter       float64
}

// Geometric primitives
type Point struct {
    X, Y float64
}

type Edge struct {
    Start    Point
    End      Point
    Plot1    PlotID
    Plot2    PlotID  // Adjacent plot
}
```

## Generation Parameters

### Recommended Defaults

```yaml
map_generation:
  # Size
  plot_count: 2000
  dimensions:
    width: 1000.0
    height: 600.0
  
  # Projection
  projection:
    type: CYLINDRICAL
    wrap_horizontal: true
    wrap_vertical: false
    pole_scaling: 1.5
  
  # Terrain
  terrain:
    ocean_percentage: 0.65
    continent_count: 3
    island_frequency: 0.15
    coastal_roughness: 0.5
  
  # Resources
  resource_density: 0.3
  climate_variance: 0.7
  
  # Generation
  random_seed: 0  # 0 = random seed
  relaxation_steps: 2
```

### Parameter Ranges

| Parameter | Min | Max | Description |
|-----------|-----|-----|-------------|
| plot_count | 100 | 10000 | Number of plots on the map |
| ocean_percentage | 0.0 | 1.0 | Portion of map that is ocean |
| continent_count | 1 | 10 | Number of major landmasses |
| island_frequency | 0.0 | 1.0 | How common small islands are |
| pole_scaling | 1.0 | 3.0 | Size increase at poles |
| resource_density | 0.0 | 1.0 | How abundant resources are |
| relaxation_steps | 0 | 10 | Lloyd's relaxation iterations |

## Performance Considerations

### Generation Time

- Target: < 5 seconds for standard map (2000 plots)
- Voronoi generation: O(n log n)
- Neighbor resolution: O(n)
- Terrain generation: O(n * m) where m is avg neighbors per plot
- Attribute calculation: O(n)

### Memory Usage

- Each plot: ~500 bytes (including attributes)
- 2000 plots: ~1 MB base memory
- Additional overhead for generation: ~2-3 MB
- Total: < 5 MB for standard map

### Optimization Strategies

1. **Spatial Indexing**: Use quadtree or R-tree for fast spatial queries
2. **Lazy Loading**: Load plot details on-demand for large maps
3. **Chunking**: Divide large maps into regions for parallel generation
4. **Caching**: Cache expensive calculations (distances, paths)
5. **Serialization**: Use efficient binary format for map storage

## Extensibility and Future Features

### Planned Extensions

1. **Multi-Layer Maps**
   - Surface layer (current implementation)
   - Underground layer (caves, resources)
   - Sky/space layer (for late-game content)

2. **Dynamic Map Changes**
   - Terrain transformation (e.g., desertification, reforestation)
   - Sea level changes
   - Volcanic activity creating new land
   - Climate shifts affecting temperature and humidity

3. **Advanced Resources**
   - Renewable vs non-renewable resources
   - Resource depletion and regeneration
   - Discovery mechanics (revealing hidden resources)

4. **Climate System**
   - Wind patterns affecting humidity
   - Ocean currents affecting temperature
   - Seasonal variations
   - Weather events (storms, droughts)

5. **Map Editor**
   - Manual plot editing
   - Custom scenario creation
   - Import/export functionality

### API Surface

```go
// Generator interface
type MapGenerator interface {
    Generate(config MapConfig) (*Map, error)
    GenerateWithSeed(config MapConfig, seed int64) (*Map, error)
    Validate(config MapConfig) error
}

// Query interface
type MapQuery interface {
    GetPlot(id PlotID) (*Plot, error)
    GetNeighbors(id PlotID) ([]*Plot, error)
    FindPlots(filter PlotFilter) ([]*Plot, error)
    GetPlotsInRadius(center Point, radius float64) ([]*Plot, error)
}

// Modification interface
type MapModifier interface {
    UpdateAttribute(plotID PlotID, attribute string, value interface{}) error
    SetTerrain(plotID PlotID, terrain TerrainType) error
    AddResource(plotID PlotID, resource Resource) error
    RemoveResource(plotID PlotID, resourceType ResourceType) error
}
```

## Testing Strategy

### Unit Tests

- Voronoi generation correctness
- Neighbor relationship validation
- Edge wrapping logic
- Attribute calculation formulas
- Configuration validation

### Integration Tests

- Full map generation pipeline
- Different projection types
- Various ocean percentages
- Resource distribution
- Serialization/deserialization

### Performance Tests

- Generation time benchmarks
- Memory usage profiling
- Scalability testing (100 to 10,000 plots)
- Query performance

### Quality Metrics

- All plots have at least 3 neighbors (except edge cases)
- Neighbor relationships are symmetric
- Ocean percentage within ±5% of target
- No orphaned or disconnected plots (unless intended)
- All plots have valid attributes within expected ranges

## References

### Algorithms
- Fortune's Algorithm for Voronoi diagrams
- Bowyer-Watson algorithm for Delaunay triangulation
- Lloyd's relaxation for centroidal Voronoi tessellations
- Perlin/Simplex noise for natural-looking terrain

### Similar Implementations
- Civilization V/VI map generation
- Crusader Kings map system
- Procedural generation techniques from Dwarf Fortress
- Red Blob Games articles on map generation

## Appendix

### Terrain Type Characteristics

| Terrain | Fertility | Movement Cost | Resources |
|---------|-----------|---------------|-----------|
| Ocean | 0.0 | N/A | Fish, Oil |
| Coast | 0.3 | 1.5 | Fish, Salt |
| Grassland | 0.8 | 1.0 | Wheat, Cattle |
| Plains | 0.6 | 1.0 | Horses, Wheat |
| Desert | 0.1 | 2.0 | Oil, Gold |
| Tundra | 0.2 | 2.0 | Furs, Oil |
| Forest | 0.5 | 2.0 | Wood, Deer |
| Jungle | 0.4 | 3.0 | Spices, Gems |
| Mountain | 0.0 | 3.0 | Iron, Gold, Stone |
| Hill | 0.4 | 2.0 | Iron, Stone |
| Swamp | 0.3 | 3.0 | Sugar |
| Ice | 0.0 | N/A | None |

### Climate Calculation Formulas

**Temperature**:
```
// Constants
equator = map_height / 2           // Equator at center of map
max_latitude = map_height / 2      // Distance from equator to pole

// Calculation
base_temperature = 30 - (abs(latitude - equator) / max_latitude * 40)
altitude_modifier = -0.0065 * altitude  // Celsius per meter (standard lapse rate)
final_temperature = base_temperature + altitude_modifier + noise(-5, 5)

// Result: ~30°C at equator, ~-10°C at poles at sea level
```

**Humidity**:
```
// distance_to_water is in world units (same as plot coordinates)
// 100 is the characteristic distance: plots within 100 units have high humidity
distance_to_water = min_distance_to_ocean_or_lake
base_humidity = 0.8 / (1 + distance_to_water / 100)
terrain_modifier = terrain_specific_modifier  // e.g., +0.3 for jungle, -0.3 for desert
final_humidity = clamp(base_humidity + terrain_modifier + noise(-0.2, 0.2), 0, 1)

// Result: 0.8 at coast, 0.4 at distance 100, 0.2 at distance 300
```

**Altitude**:
```
// Constants (recommended values)
initial_amplitude = 1.0            // Base amplitude for first octave
initial_frequency = 0.002          // Base frequency (controls overall scale)
max_altitude = 8000                // Maximum altitude in meters (e.g., ~Mt Everest)
octave_count = 5                   // Number of octaves for detail

// Use Perlin noise with multiple octaves
altitude = 0
for octave = 0 to octave_count - 1:
    amplitude = initial_amplitude / (2 ^ octave)
    frequency = initial_frequency * (2 ^ octave)
    altitude += perlin_noise(x * frequency, y * frequency) * amplitude

// Normalize and scale
altitude = (altitude + 1) / 2 * max_altitude  // Convert -1..1 to 0..max_altitude

// Adjust for terrain type (ocean = negative, mountains = high positive)
if terrain == OCEAN:
    altitude = -altitude * 0.5     // Ocean floor: -4000m to 0m
else if terrain == MOUNTAIN:
    altitude = altitude * 1.5      // Mountains: up to 12000m
```

## Conclusion

This design provides a flexible and extensible foundation for the map generation system. The combination of Voronoi diagrams for irregular plots, configurable projection systems, and an extensible attribute system ensures that the map generator can support a wide variety of gameplay scenarios while maintaining good performance and allowing for future enhancements.

The key design principles are:
1. **Flexibility**: Configurable parameters for different map types
2. **Extensibility**: Easy to add new attributes and features
3. **Performance**: Efficient algorithms and data structures
4. **Realism**: Natural-looking maps with logical geographic relationships
5. **Maintainability**: Clear APIs and well-defined interfaces

Implementation should proceed incrementally, starting with basic Voronoi generation and neighbor relationships, then adding terrain generation, and finally implementing the full attribute system.
