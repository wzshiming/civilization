# Design Document: Maps Generator

**Document ID**: 001  
**Created**: 2025-12-18  
**Status**: Draft  
**Author**: Civilization Development Team

## Overview

Map generation system using Voronoi tessellation to create irregular plots with neighbor relationships, configurable projections, and extensible attributes.

## Core Requirements

### 1. Irregular Plot Generation

Use Voronoi diagram generation with randomly distributed seed points. Each Voronoi cell becomes a plot with irregular shape and varying size.

### 2. Neighbor Relationships

Each plot maintains bidirectional references to adjacent plots with distance and border length information.

**Data Structure**:
```
Plot {
  id: unique identifier
  neighbors: []Neighbor  // List of adjacent plots with relationship metadata
  center: Point          // Geographic center
  vertices: []Point      // Polygon vertices defining the plot boundary
  edges: []Edge          // Edges with information about shared borders
}

Neighbor {
  plotID: PlotID         // ID of the neighboring plot
  distance: float        // Distance between plot centers
  sharedBorderLength: float  // Length of the shared border edge
}
```

### 3. Configurable Map Generation

#### 3.1 Spherical Projection

```
ProjectionConfig {
  wrapHorizontal: bool  // Connect left/right edges
  wrapVertical: bool    // Connect top/bottom edges
  poleScaling: float    // Size multiplier for polar regions (1.0 = no scaling)
}

// Projection types are determined by wrap configuration:
// - Flat map: wrapHorizontal=false, wrapVertical=false
// - Cylindrical: wrapHorizontal=true, wrapVertical=false
// - Spherical: wrapHorizontal=true, wrapVertical=true
```

Edge wrapping creates neighbor relationships across boundaries. `poleScaling` simulates geographic distortion on spherical projections.

#### 3.2 Terrain Configuration

```
TerrainConfig {
  oceanPercentage: float  // 0.0 to 1.0
  continentCount: int
  islandFrequency: float  // 0.0 to 1.0
  coastalRoughness: float // 0.0 to 1.0
}
```

Generation: seed continents, expand landmasses to target ocean percentage, add islands, refine coastlines.

### 4. Extensible Plot Attributes

**Requirement**: Plots must support a wide range of attributes that can be dynamically updated and extended.

**Core Attributes**:

```
PlotAttributes {
  terrain: TerrainType      // OCEAN, GRASSLAND, DESERT, FOREST, etc.
  altitude: float           // Meters above sea level (negative for ocean floor)
  temperature: float        // In Celsius
  humidity: float           // 0.0 to 1.0
  resources: []Resource
  fertility: float          // 0.0 to 1.0
  ownership: PlayerID
  population: int
  development: float        // 0.0 to 1.0
  culture: CultureID
  customAttributes: map[string]any  // Extensible key-value store
}

Resource {
  type: ResourceType   // IRON, HORSES, OIL, WHEAT, etc.
  abundance: float     // 0.0 to 1.0
  discovered: bool
}

TerrainType: OCEAN, COAST, GRASSLAND, PLAINS, DESERT, TUNDRA,
             FOREST, JUNGLE, MOUNTAIN, HILL, SWAMP, ICE
```

Base attributes are strongly typed; `customAttributes` allows runtime extensions.

## Technical Approach

### Algorithms

- **Voronoi Generation**: Fortune's Algorithm or Bowyer-Watson (O(n log n))
- **Neighbor Relationships**: Delaunay triangulation as dual graph
- **Plot Uniformity**: Optional Lloyd's relaxation

### Generation Pipeline

1. **Configuration** - Validate parameters, initialize seed
2. **Seed Generation** - Random points with optional Lloyd's relaxation
3. **Voronoi Computation** - Generate plot boundaries and vertices
4. **Neighbor Resolution** - Build adjacency with edge wrapping
5. **Terrain Generation** - Continent expansion to target ocean percentage
6. **Attribute Assignment** - Altitude, temperature, humidity, resources
7. **Post-Processing** - Validation and serialization

### Data Structures

```
Map {
    id: string
    config: MapConfig
    plots: map[PlotID]Plot
    plotCount: int
    createdAt: timestamp
}

MapConfig {
    plotCount: int
    dimensions: Dimensions  // width x height
    projection: ProjectionConfig
    terrain: TerrainConfig
    resourceDensity: float
    climateVariance: float
    randomSeed: int
    relaxationSteps: int  // Lloyd's relaxation iterations
}

Plot {
    id: PlotID
    center: Point
    vertices: []Point
    neighbors: []Neighbor
    attributes: PlotAttributes
    area: float
    perimeter: float
}

Point {
    x: float
    y: float
}

Edge {
    start: Point
    end: Point
    plot1: PlotID
    plot2: PlotID  // Adjacent plot
}
```

## Generation Parameters

### Recommended Defaults

```yaml
map_generation:
  # Size
  plot_count: 2000
  dimensions:
    width: 1000.0
    height: 600.0
  
  # Projection
  projection:
    wrap_horizontal: true
    wrap_vertical: false
    pole_scaling: 1.5
  
  # Terrain
  terrain:
    ocean_percentage: 0.65
    continent_count: 3
    island_frequency: 0.15
    coastal_roughness: 0.5
  
  # Resources
  resource_density: 0.3
  climate_variance: 0.7
  
  # Generation
  random_seed: 0  # 0 = random seed
  relaxation_steps: 2
```

### Parameter Ranges

| Parameter | Min | Max | Description |
|-----------|-----|-----|-------------|
| plot_count | 100 | 10000 | Number of plots on the map |
| ocean_percentage | 0.0 | 1.0 | Portion of map that is ocean |
| continent_count | 1 | 10 | Number of major landmasses |
| island_frequency | 0.0 | 1.0 | How common small islands are |
| pole_scaling | 1.0 | 3.0 | Size increase at poles |
| resource_density | 0.0 | 1.0 | How abundant resources are |
| relaxation_steps | 0 | 10 | Lloyd's relaxation iterations |

## Performance

- **Target**: <5s for 2000 plots
- **Complexity**: O(n log n) generation, O(n) neighbor resolution
- **Memory**: ~1 MB for 2000 plots
- **Optimization**: Spatial indexing, lazy loading, caching, parallel generation

## Extensibility

Planned features: multi-layer maps (surface/underground/space), dynamic terrain changes, advanced resource mechanics, climate systems, map editor.

### API Surface

```
MapGenerator {
    generate(config: MapConfig): Map
    generateWithSeed(config: MapConfig, seed: int): Map
    validate(config: MapConfig): bool
}

MapQuery {
    getPlot(id: PlotID): Plot
    getNeighbors(id: PlotID): []Plot
    findPlots(filter: PlotFilter): []Plot
    getPlotsInRadius(center: Point, radius: float): []Plot
}

MapModifier {
    updateAttribute(plotID: PlotID, attribute: string, value: any)
    setTerrain(plotID: PlotID, terrain: TerrainType)
    addResource(plotID: PlotID, resource: Resource)
    removeResource(plotID: PlotID, resourceType: ResourceType)
}
```

## Testing

- **Unit**: Voronoi generation, neighbor validation, edge wrapping, attributes
- **Integration**: Full pipeline, projections, terrain distribution
- **Performance**: Generation time, memory usage, scalability
- **Quality**: Symmetric neighbors, ocean percentage ±5%, valid attributes

## References

Fortune's Algorithm, Bowyer-Watson, Lloyd's relaxation, Perlin/Simplex noise. See Civilization V/VI, Crusader Kings, Dwarf Fortress, Red Blob Games.

## Appendix

### Terrain Type Characteristics

| Terrain | Fertility | Movement Cost | Resources |
|---------|-----------|---------------|-----------|
| Ocean | 0.0 | N/A | Fish, Oil |
| Coast | 0.3 | 1.5 | Fish, Salt |
| Grassland | 0.8 | 1.0 | Wheat, Cattle |
| Plains | 0.6 | 1.0 | Horses, Wheat |
| Desert | 0.1 | 2.0 | Oil, Gold |
| Tundra | 0.2 | 2.0 | Furs, Oil |
| Forest | 0.5 | 2.0 | Wood, Deer |
| Jungle | 0.4 | 3.0 | Spices, Gems |
| Mountain | 0.0 | 3.0 | Iron, Gold, Stone |
| Hill | 0.4 | 2.0 | Iron, Stone |
| Swamp | 0.3 | 3.0 | Sugar |
| Ice | 0.0 | N/A | None |

### Climate Calculation Formulas

**Temperature**:
```
// Constants
equator = map_height / 2           // Equator at center of map
max_latitude = map_height / 2      // Distance from equator to pole

// Calculation
base_temperature = 30 - (abs(latitude - equator) / max_latitude * 40)
altitude_modifier = -0.0065 * altitude  // Celsius per meter (standard lapse rate)
final_temperature = base_temperature + altitude_modifier + noise(-5, 5)

// Result: ~30°C at equator, ~-10°C at poles at sea level
```

**Humidity**:
```
// Calculate minimum distance to any water body (ocean or lake)
// distance_to_water is in world units (same as plot coordinates)
// Can be computed using spatial index or breadth-first search from water plots
distance_to_water = min_distance_to_ocean_or_lake()

// 100 is the characteristic distance: plots within 100 units have high humidity
base_humidity = 0.8 / (1 + distance_to_water / 100)
terrain_modifier = terrain_specific_modifier  // e.g., +0.3 for jungle, -0.3 for desert
final_humidity = clamp(base_humidity + terrain_modifier + noise(-0.2, 0.2), 0, 1)

// Result: 0.8 at coast, 0.4 at distance 100, 0.2 at distance 300
```

**Altitude**:
```
// Constants (recommended values)
initial_amplitude = 1.0            // Base amplitude for first octave
initial_frequency = 0.002          // Base frequency (controls overall scale)
max_altitude = 8000                // Maximum altitude in meters (e.g., ~Mt Everest)
octave_count = 5                   // Number of octaves for detail

// Use Perlin noise with multiple octaves
// Note: ^ represents exponentiation (power), same as ** or pow() in many languages
altitude = 0
for octave = 0 to octave_count - 1:
    amplitude = initial_amplitude / (2 ^ octave)   // 2 to the power of octave
    frequency = initial_frequency * (2 ^ octave)   // 2 to the power of octave
    altitude += perlin_noise(x * frequency, y * frequency) * amplitude

// Normalize and scale
altitude = (altitude + 1) / 2 * max_altitude  // Convert -1..1 to 0..max_altitude

// Post-processing: Adjust altitude based on pre-determined terrain type
// (terrain type is assigned first based on raw altitude thresholds)
if terrain == OCEAN:
    altitude = -altitude * 0.5     // Ocean floor: -4000m to 0m
else if terrain == MOUNTAIN:
    altitude = altitude * 1.5      // Mountains: up to 12000m
    
// Order of operations: 
// 1. Generate raw altitude from noise
// 2. Assign terrain type based on altitude thresholds (low = ocean, high = mountain, etc.)
// 3. Refine altitude values based on assigned terrain type
```
