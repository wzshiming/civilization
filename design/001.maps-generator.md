# Maps Generator

## Overview

Map generation system using Voronoi tessellation to create irregular plots with neighbor relationships, configurable projections, and extensible attributes.

## Requirements

- **Irregular Plots**: Voronoi diagram generation creates organic, non-uniform plot shapes
- **Neighbor Relationships**: Each plot tracks adjacent plots with distance and border metrics
- **Configurable Projections**: Support flat, cylindrical, and spherical map types via edge wrapping
- **Terrain Generation**: Configurable ocean percentage, continents, islands, and coastlines
- **Extensible Attributes**: Dynamic plot properties including terrain, climate, resources, and gameplay data

## Data Structures

All coordinates use abstract world units. Map dimensions define the coordinate space (e.g., width=1000 means x ranges from 0 to 1000).

### Core Types

```
Point {
    x: float  // World coordinates
    y: float
}

Edge {
    start: Point
    end: Point
    plot1: PlotID
    plot2: PlotID  // Adjacent plot
}

Neighbor {
    plotID: PlotID               // ID of the neighboring plot
    distance: float              // Distance between plot centers
    sharedBorderLength: float    // Length of the shared border edge
}

Plot {
    id: PlotID
    center: Point
    vertices: []Point
    neighbors: []Neighbor
    attributes: PlotAttributes
    area: float
    perimeter: float
}
```

### Plot Attributes

```
PlotAttributes {
    terrain: TerrainType      // OCEAN, GRASSLAND, DESERT, FOREST, etc.
    terrainDiscoveredBy: []PlayerID  // Players who have discovered this terrain
    altitude: float           // Meters above sea level (negative for ocean floor)
    temperature: float        // In Celsius
    humidity: float           // 0.0 to 1.0
    resources: []Resource
    fertility: float          // 0.0 to 1.0
    ownership: PlayerID
    population: int
    development: float        // 0.0 to 1.0
    culture: CultureID
}

Resource {
    type: ResourceType          // IRON, HORSES, OIL, WHEAT, etc.
    abundance: float            // 0.0 to 1.0
    discoveredBy: []PlayerID    // Players who have discovered this resource
    currentQuantity: float      // Current available quantity
    quantityOnLine: float       // Quantity being extracted/produced
    dailyChange: float          // Daily change rate
    monthlyChange: float        // Monthly change rate
}

TerrainType: OCEAN, COAST, GRASSLAND, PLAINS, DESERT, TUNDRA,
             FOREST, JUNGLE, MOUNTAIN, HILL, SWAMP, ICE
```

**Discovery State**: Players are added to terrainDiscoveredBy and resource.discoveredBy arrays when they explore plots. State persists across game sessions.

### Map Structure

```
Map {
    id: string
    config: MapConfig
    plots: map[PlotID]Plot
    plotCount: int
    createdAt: timestamp
}

MapConfig {
    plotCount: int
    dimensions: Dimensions  // width x height
    projection: ProjectionConfig
    terrain: TerrainConfig
    resourceDensity: float
    climateVariance: float
    randomSeed: int
    relaxationSteps: int  // Lloyd's relaxation iterations
}

ProjectionConfig {
    wrapHorizontal: bool  // Connect left/right edges
    wrapVertical: bool    // Connect top/bottom edges
    poleScaling: float    // Size multiplier for polar regions (1.0 = no scaling)
}
// Projection types: flat (no wrap), cylindrical (horizontal wrap), spherical (both wrap)

TerrainConfig {
    oceanPercentage: float  // 0.0 to 1.0
    continentCount: int
    islandFrequency: float  // 0.0 to 1.0
    coastalRoughness: float // 0.0 to 1.0
}
```

## Generation Pipeline

1. **Configuration** - Validate parameters, initialize seed
2. **Seed Generation** - Random points with optional Lloyd's relaxation
3. **Voronoi Computation** - Generate plot boundaries and vertices
4. **Neighbor Resolution** - Build adjacency with edge wrapping
5. **Terrain Generation** - Continent expansion to target ocean percentage
6. **Attribute Assignment** - Altitude, temperature, humidity, resources
7. **Post-Processing** - Validation and serialization

### Algorithms

- **Voronoi Generation**: Fortune's Algorithm or Bowyer-Watson (O(n log n))
- **Neighbor Relationships**: Delaunay triangulation as dual graph
- **Plot Uniformity**: Optional Lloyd's relaxation

## Generation Parameters

### Command Line Flags

```
--plot-count=2000              # Number of plots (100-10000)
--width=1000.0                 # Map width in world units
--height=600.0                 # Map height in world units

--wrap-horizontal              # Enable horizontal wrapping (cylindrical/spherical)
--wrap-vertical                # Enable vertical wrapping (spherical)
--pole-scaling=1.5             # Size multiplier for polar regions (1.0-3.0)

--ocean-percentage=0.65        # Portion of map that is ocean (0.0-1.0)
--continent-count=3            # Number of major landmasses (1-10)
--island-frequency=0.15        # How common small islands are (0.0-1.0)
--coastal-roughness=0.5        # Coastline jaggedness (0.0-1.0)

--resource-density=0.3         # How abundant resources are (0.0-1.0)
--climate-variance=0.7         # Climate variation (0.0-1.0)

--random-seed=0                # Random seed (0 = random)
--relaxation-steps=2           # Lloyd's relaxation iterations (0-10)
```

## Performance

- **Target**: <5s for 2000 plots
- **Complexity**: O(n log n) generation, O(n) neighbor resolution
- **Memory**: ~1 MB for 2000 plots
- **Optimization**: Spatial indexing, lazy loading, caching, parallel generation

## Extensibility

Planned features: multi-layer maps (surface/underground/space), dynamic terrain changes, advanced resource mechanics, climate systems, map editor.

## Testing

- **Unit**: Voronoi generation, neighbor validation, edge wrapping, attributes
- **Integration**: Full pipeline, projections, terrain distribution
- **Performance**: Generation time, memory usage, scalability
- **Quality**: Symmetric neighbors, ocean percentage ±5%, valid attributes

## References

Fortune's Algorithm, Bowyer-Watson, Lloyd's relaxation, Perlin/Simplex noise. See Civilization V/VI, Crusader Kings, Dwarf Fortress, Red Blob Games.

## Appendix

### Terrain Type Characteristics

| Terrain | Fertility | Movement Cost | Resources |
|---------|-----------|---------------|-----------|
| Ocean | 0.0 | N/A | Fish, Oil |
| Coast | 0.3 | 1.5 | Fish, Salt |
| Grassland | 0.8 | 1.0 | Wheat, Cattle |
| Plains | 0.6 | 1.0 | Horses, Wheat |
| Desert | 0.1 | 2.0 | Oil, Gold |
| Tundra | 0.2 | 2.0 | Furs, Oil |
| Forest | 0.5 | 2.0 | Wood, Deer |
| Jungle | 0.4 | 3.0 | Spices, Gems |
| Mountain | 0.0 | 3.0 | Iron, Gold, Stone |
| Hill | 0.4 | 2.0 | Iron, Stone |
| Swamp | 0.3 | 3.0 | Sugar |
| Ice | 0.0 | N/A | None |

### Climate Calculation Formulas

**Temperature**:
```
// Constants
equator = map_height / 2           // Equator at center of map
max_latitude = map_height / 2      // Distance from equator to pole

// Calculation
base_temperature = 30 - (abs(latitude - equator) / max_latitude * 40)
altitude_modifier = -0.0065 * altitude  // Celsius per meter (standard lapse rate)
final_temperature = base_temperature + altitude_modifier + noise(-5, 5)

// Result: ~30°C at equator, ~-10°C at poles at sea level
```

**Humidity**:
```
// Calculate minimum distance to any water body (ocean or lake)
// distance_to_water is in world units (same as plot coordinates)
// Can be computed using spatial index or breadth-first search from water plots
distance_to_water = min_distance_to_ocean_or_lake()

// 100 is the characteristic distance: plots within 100 units have high humidity
base_humidity = 0.8 / (1 + distance_to_water / 100)
terrain_modifier = terrain_specific_modifier  // e.g., +0.3 for jungle, -0.3 for desert
final_humidity = clamp(base_humidity + terrain_modifier + noise(-0.2, 0.2), 0, 1)

// Result: 0.8 at coast, 0.4 at distance 100, 0.2 at distance 300
```

**Altitude**:
```
// Constants (recommended values)
initial_amplitude = 1.0            // Base amplitude for first octave
initial_frequency = 0.002          // Base frequency (controls overall scale)
max_altitude = 8000                // Maximum altitude in meters (e.g., ~Mt Everest)
octave_count = 5                   // Number of octaves for detail

// Use Perlin noise with multiple octaves
altitude = 0
for octave = 0 to octave_count - 1:
    amplitude = initial_amplitude / pow(2, octave)
    frequency = initial_frequency * pow(2, octave)
    altitude += perlin_noise(x * frequency, y * frequency) * amplitude

// Normalize and scale
altitude = (altitude + 1) / 2 * max_altitude  // Convert -1..1 to 0..max_altitude

// Post-processing: Adjust altitude based on pre-determined terrain type
// (terrain type is assigned first based on raw altitude thresholds)
if terrain == OCEAN:
    altitude = -altitude * 0.5     // Ocean floor: -4000m to 0m
else if terrain == MOUNTAIN:
    altitude = altitude * 1.5      // Mountains: up to 12000m
    
// Order of operations: 
// 1. Generate raw altitude from noise
// 2. Assign terrain type based on altitude thresholds (low = ocean, high = mountain, etc.)
// 3. Refine altitude values based on assigned terrain type
```
