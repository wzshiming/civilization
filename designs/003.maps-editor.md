# Maps Editor

See [000.definition.md](000.definition.md) for base type definitions, [001.maps.md](001.maps.md) for map structure, and [002.maps-generator.md](002.maps-generator.md) for map generation.

## Overview

This document defines the map editor system that enables interactive creation, modification, and customization of game maps. The editor provides both a programmatic API and a user interface for manipulating maps created by the map generator or unit them from scratch.

## Additional ID Types

Editor-specific ID types extending the base definitions:

```
EditID: UUID          // Unique identifier for an edit operation
ToolID: UUID          // Unique identifier for an editor tool
ValidatorID: UUID     // Unique identifier for a validator
IssueID: UUID         // Unique identifier for a validation issue
FormatID: string      // Identifier for export/import format
LayerID: UUID         // Unique identifier for a UI layer
PluginID: string      // Unique identifier for an editor plugin
```

## Design Goals

1. **Interactive Editing**: Provide real-time visual feedback for map modifications
2. **Non-Destructive**: Support undo/redo and preserve map history
3. **Validation**: Ensure map integrity and valid relationships between elements
4. **Flexible Workflow**: Support both automated generation with manual tweaks and complete manual creation
5. **Export/Import**: Enable saving and loading maps in various formats
6. **Extensible Tools**: Provide a plugin-based system for custom editing tools
7. **Performance**: Handle large maps (10,000+ plots) with smooth interaction

## Editor Architecture

```
MapEditor {
    map: Map
    history: EditHistory
    selection: Selection
    tools: []EditorTool
    validators: []Validator
    config: EditorConfig
    
    // Core operations
    ApplyEdit(edit: Edit) -> Result
    Undo() -> Result
    Redo() -> Result
    Validate() -> ValidationResult
    Save(format: ExportFormat) -> Result
    Load(source: string) -> Result
}

EditorConfig {
    autoValidate: bool
    maxHistorySize: int
    autoSave: bool
    autoSaveInterval: int  // seconds
    snapToGrid: bool
    gridSize: float
    showNeighborConnections: bool
    highlightInvalidPlots: bool
}
```

## Edit History System

```
EditHistory {
    undoStack: []Edit
    redoStack: []Edit
    maxSize: int
    
    Push(edit: Edit)
    Undo() -> Edit?
    Redo() -> Edit?
    Clear()
}

Edit {
    editID: EditID
    timestamp: int
    editType: EditType
    previousState: any
    newState: any
    affectedPlots: []PlotID
    
    Apply(map: Map) -> Result
    Revert(map: Map) -> Result
}

EditType enum {
    TERRAIN_CHANGE
    PLOT_SPLIT
    PLOT_MERGE
    PLOT_CREATE
    PLOT_DELETE
    NEIGHBOR_ADD
    NEIGHBOR_REMOVE
    ATTRIBUTE_CHANGE
    BUILDING_ADD
    BUILDING_REMOVE
    UNIT_ADD
    UNIT_REMOVE
    UNIT_MOVE
    CLUSTER_ADD
    CLUSTER_REMOVE
    CLUSTER_MODIFY
    SPECIES_ADD
    SPECIES_REMOVE
    RESOURCE_CHANGE
    BATCH_EDIT
}
```

## Selection System

```
Selection {
    selectedPlots: []PlotID
    selectionMode: SelectionMode
    filterCriteria: FilterCriteria?
    
    Add(plotID: PlotID)
    Remove(plotID: PlotID)
    Clear()
    SelectAll()
    SelectByFilter(criteria: FilterCriteria)
    Invert()
    ExpandToNeighbors(depth: int)
    GetBoundingBox() -> BoundingBox
}

SelectionMode enum {
    SINGLE      // Only one plot at a time
    MULTIPLE    // Multiple individual plots
    REGION      // Contiguous region
    PAINT       // Brush-based selection
}

FilterCriteria {
    terrainTypes: []TerrainTypeID?
    hasUnits: bool?
    unitTypes: []UnitTypeID?
    minArea: float?
    maxArea: float?
    ownerPlayerID: PlayerID?
    hasResources: bool?
    resourceTypes: []ResourceTypeID?
    customPredicate: (plot: Plot) -> bool
}

BoundingBox {
    minX: float
    minY: float
    maxX: float
    maxY: float
}
```

## Editor Tools

```
EditorTool interface {
    toolID: ToolID
    name: string
    description: string
    icon: string
    hotkey: string?
    
    OnActivate(editor: MapEditor)
    OnDeactivate(editor: MapEditor)
    OnMouseDown(point: Point, editor: MapEditor) -> ToolResult
    OnMouseMove(point: Point, editor: MapEditor) -> ToolResult
    OnMouseUp(point: Point, editor: MapEditor) -> ToolResult
    OnKeyPress(key: string, editor: MapEditor) -> ToolResult
}

ToolResult {
    editsApplied: []Edit
    cursorStyle: CursorStyle
    preview: PreviewData?
}
```

### Built-in Tools

#### SelectTool
```
SelectTool implements EditorTool {
    selectionMode: SelectionMode
    
    // Click to select single plot
    // Shift+Click to add to selection
    // Ctrl+Click to remove from selection
    // Drag to select region
}
```

#### PaintTool
```
PaintTool implements EditorTool {
    brushSize: float
    brushShape: BrushShape
    paintAction: PaintAction
    
    // Paint terrain types
    // Paint attributes
    // Smooth/blend terrain boundaries
}

BrushShape enum {
    CIRCLE
    SQUARE
    CUSTOM
}

PaintAction {
    actionType: PaintActionType
    value: any
}

PaintActionType enum {
    SET_TERRAIN
    SET_ATTRIBUTE
    ADD_RESOURCE
    REMOVE_RESOURCE
    SMOOTH_TERRAIN
}
```

#### PlotSplitTool
```
PlotSplitTool implements EditorTool {
    splitLine: Line?
    
    // Click and drag to draw line splitting plot
    // Generates new plot boundaries along line
    // Updates neighbor relationships
}
```

#### PlotMergeTool
```
PlotMergeTool implements EditorTool {
    // Click first plot, then neighboring plot
    // Merges two adjacent plots into one
    // Combines attributes based on merge strategy
    
    mergeStrategy: MergeStrategy
}

MergeStrategy {
    terrainResolution: TerrainResolutionType
    attributeResolution: AttributeResolutionType
}

TerrainResolutionType enum {
    USE_FIRST
    USE_SECOND
    USE_LARGER_AREA
}

AttributeResolutionType enum {
    COMBINE     // Sum/merge attributes
    USE_FIRST
    USE_SECOND
    AVERAGE
}
```

#### PlotGeneratorTool
```
PlotGeneratorTool implements EditorTool {
    regionConfig: RegionGeneratorConfig
    
    // Select region and generate new plots within it
    // Useful for regenerating specific areas
}

RegionGeneratorConfig {
    plotCount: int
    generationMethod: GenerationMethod
    terrainConfig: TerrainConfig?
    preserveBoundary: bool
}

GenerationMethod enum {
    VORONOI
    GRID
    HEXAGONAL
    RANDOM
}
```

#### AttributeEditorTool
```
AttributeEditorTool implements EditorTool {
    attributeType: AttributeType
    
    // Double-click plot to open attribute editor panel
    // Edit all plot attributes interactively
}
```

#### TerrainSmoothTool
```
TerrainSmoothTool implements EditorTool {
    smoothingStrength: float  // 0.0 to 1.0
    smoothingRadius: int      // neighbor depth
    
    // Click plot to smooth terrain transitions
    // Makes terrain changes more gradual
}
```

#### UnitEditorTool
```
UnitEditorTool implements EditorTool {
    unitCategory: UnitCategory
    selectedUnitTypeID: UnitTypeID?
    
    // Click plot to add selected unit type
    // Right-click unit to remove or modify
    // Drag to move movable units between plots
}

UnitCategory enum {
    BUILDING    // Cave, Bonfire, Farm ground, etc.
    MOVABLE     // Hunting team, Trade team, Warriors team, etc.
}
```

#### ClusterEditorTool
```
ClusterEditorTool implements EditorTool {
    clusterCategory: ClusterCategory
    selectedClusterTypeID: ClusterTypeID?
    defaultSize: int
    
    // Click plot to add cluster of selected type
    // Right-click cluster to remove or modify
    // Drag to move clusters between plots
    // Shift+click to modify cluster properties
}

ClusterCategory enum {
    ENLIGHTENED    // Human, Elf, Orc, etc.
    ANIMAL         // Horse, Cattle, Chicken, Goat, Sheep, etc.
}
```

## Editing Operations

### Terrain Editing

```
SetTerrainType(plotIDs: []PlotID, terrainTypeID: TerrainTypeID) -> Edit
GetTerrainType(plotID: PlotID) -> TerrainTypeID
BatchSetTerrain(assignments: map[PlotID]TerrainTypeID) -> Edit
```

### Plot Manipulation

```
SplitPlot(plotID: PlotID, splitLine: Line) -> Edit {
    // 1. Calculate intersection points of line with plot boundary
    // 2. Create two new plot geometries
    // 3. Distribute attributes between new plots
    // 4. Update neighbor relationships
    // 5. Return edit containing old plot state and two new plots
}

MergePlots(plotID1: PlotID, plotID2: PlotID, strategy: MergeStrategy) -> Edit {
    // 1. Validate plots are neighbors
    // 2. Combine geometries (union of polygons)
    // 3. Merge attributes according to strategy
    // 4. Update neighbor relationships
    // 5. Return edit containing both old plots and merged plot
}

CreatePlot(vertices: []Point, attributes: PlotAttributes) -> Edit
DeletePlot(plotID: PlotID) -> Edit
ModifyPlotBoundary(plotID: PlotID, newVertices: []Point) -> Edit
```

### Attribute Editing

```
SetPlotAttribute(plotID: PlotID, attribute: string, value: any) -> Edit
BatchSetAttribute(plotIDs: []PlotID, attribute: string, value: any) -> Edit

// Specific attribute editors
SetOwner(plotIDs: []PlotID, playerID: PlayerID?) -> Edit
AddUnit(plotID: PlotID, unit: Unit) -> Edit
RemoveUnit(plotID: PlotID, unitID: UnitID) -> Edit
```

### Unit Editing

```
// Building unit operations
AddBuildingUnit(plotID: PlotID, unitTypeID: UnitTypeID) -> Edit {
    // 1. Validate terrain compatibility
    // 2. Create unit with specified type
    // 3. Add to plot's units list
    // 4. Initialize default storage and processes
}

RemoveBuildingUnit(plotID: PlotID, unitID: UnitID) -> Edit

ModifyBuildingUnit(plotID: PlotID, unitID: UnitID, properties: UnitProperties) -> Edit

// Movable unit operations
AddMovableUnit(plotID: PlotID, unitTypeID: UnitTypeID, ownerClusterID: ClusterID?) -> Edit {
    // 1. Create movable unit
    // 2. Assign owner cluster if specified
    // 3. Add to plot's units list
}

RemoveMovableUnit(plotID: PlotID, unitID: UnitID) -> Edit

MoveUnit(unitID: UnitID, fromPlotID: PlotID, toPlotID: PlotID) -> Edit {
    // 1. Validate destination terrain compatibility
    // 2. Remove unit from source plot
    // 3. Add unit to destination plot
    // 4. Update unit position
}

AssignWorkersToUnit(unitID: UnitID, clusterIDs: []ClusterID) -> Edit

UnitProperties {
    name: string?
    ownerClusterID: ClusterID?
    workerClusterIDs: []ClusterID?
}
```

### Cluster Editing

```
// Enlightened cluster operations
AddEnlightenedCluster(plotID: PlotID, clusterTypeID: ClusterTypeID, name: string, size: int) -> Edit {
    // 1. Create cluster with specified type
    // 2. Set initial size and properties
    // 3. Add to plot's clusters list
    // 4. Initialize default skills based on cluster type
}

RemoveCluster(plotID: PlotID, clusterID: ClusterID) -> Edit

ModifyCluster(clusterID: ClusterID, properties: ClusterProperties) -> Edit

// Animal cluster operations
AddAnimalCluster(plotID: PlotID, clusterTypeID: ClusterTypeID, herdSize: int) -> Edit {
    // 1. Validate terrain compatibility
    // 2. Create animal cluster
    // 3. Set herd size
    // 4. Add to plot's clusters list
}

MoveCluster(clusterID: ClusterID, fromPlotID: PlotID, toPlotID: PlotID) -> Edit {
    // 1. Validate destination terrain compatibility
    // 2. Remove cluster from source plot
    // 3. Add cluster to destination plot
}

SetClusterRelationship(clusterID: ClusterID, targetClusterID: ClusterID, favorability: float) -> Edit

ClusterProperties {
    name: string?
    size: int?
    skills: []Skill?
}
```

### Neighbor Editing

```
AddNeighbor(plotID1: PlotID, plotID2: PlotID) -> Edit
RemoveNeighbor(plotID1: PlotID, plotID2: PlotID) -> Edit
RecalculateNeighbors(plotIDs: []PlotID) -> Edit
AutoFixNeighbors() -> Edit {
    // Automatically detect and fix neighbor relationships
    // Based on geometric adjacency
}
```

### Batch Operations

```
BatchEdit {
    edits: []Edit
    description: string
    
    // Combines multiple edits into single undo/redo unit
}

ApplyBatchEdit(batch: BatchEdit) -> Result
```

## Validation System

```
Validator interface {
    validatorID: ValidatorID
    name: string
    severity: ValidationSeverity
    
    Validate(map: Map) -> []ValidationIssue
}

ValidationSeverity enum {
    ERROR      // Must be fixed before save
    WARNING    // Should be reviewed
    INFO       // Informational only
}

ValidationIssue {
    issueID: IssueID
    validatorID: ValidatorID
    severity: ValidationSeverity
    message: string
    affectedPlots: []PlotID
    suggestedFix: Edit?
}

ValidationResult {
    isValid: bool
    issues: []ValidationIssue
    errorCount: int
    warningCount: int
    infoCount: int
}
```

### Built-in Validators

```
NeighborConsistencyValidator {
    // Ensures neighbor relationships are bidirectional
    // If A neighbors B, then B must neighbor A
}

GeometryValidator {
    // Ensures plot geometries are valid
    // No self-intersecting polygons
    // No zero-area plots
    // No duplicate vertices
}

AttributeValidator {
    // Ensures required attributes are present
    // Validates attribute value ranges
    // Checks for orphaned references
}

ResourceValidator {
    // Ensures resources are valid for terrain type
    // Checks storage capacity constraints
}

NeighborGeometryValidator {
    // Ensures declared neighbors actually share edges
    // Detects missing neighbor relationships
}
```

## Export/Import System

```
ExportFormat enum {
    JSON
    GEOJSON
    SVG
    PNG
    CUSTOM
}

ImportFormat enum {
    JSON
    GEOJSON
    SHAPEFILE
    CUSTOM
}

Exporter interface {
    formatID: FormatID
    extension: string
    
    Export(map: Map, options: ExportOptions) -> Result
}

Importer interface {
    formatID: FormatID
    supportedExtensions: []string
    
    Import(source: string, options: ImportOptions) -> Map
}

ExportOptions {
    includeGeneratedData: bool
    prettyPrint: bool
    compression: CompressionType?
    imageResolution: int?  // For PNG/image exports
    customSettings: map[string]any
}

ImportOptions {
    validateOnImport: bool
    autoFixIssues: bool
    mergeStrategy: MergeStrategy?  // For importing into existing map
    customSettings: map[string]any
}
```

### JSON Export Format

```json
{
  "version": "1.0.0",
  "metadata": {
    "created": "2024-01-15T08:00:00Z",
    "modified": "2024-01-15T09:30:00Z",
    "creator": "MapEditor v1.0",
    "description": "Custom edited civilization map"
  },
  "map": {
    "plots": [...],
    "speciesTypes": [...],
    "resourceTypes": [...],
    "unitTypes": [...],
    "terrainTypes": [...],
    "skillTypes": [...],
    "religions": [...],
    "cultures": [...]
  },
  "editorData": {
    "snapToGrid": true,
    "gridSize": 10.0,
    "lastEditTimestamp": 1734512400
  }
}
```

### GeoJSON Export Format

```json
{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "geometry": {
        "type": "Polygon",
        "coordinates": [[...]]
      },
      "properties": {
        "plotID": "uuid",
        "terrainType": "grassland",
        "owner": "player1",
        "units": [...],
        "resources": [...]
      }
    }
  ]
}
```

## User Interface Components

### Editor View

```
EditorView {
    viewport: Viewport
    renderer: Renderer
    eventHandler: EventHandler
    toolManager: ToolManager
    
    Render()
    HandleEvent(event: Event)
}

Viewport {
    centerX: float
    centerY: float
    zoom: float
    rotation: float
    
    Pan(deltaX: float, deltaY: float)
    Zoom(factor: float, centerPoint: Point?)
    Rotate(degrees: float)
    FitToMap()
    FocusOnPlots(plotIDs: []PlotID)
}

Renderer {
    canvas: Canvas
    renderMode: RenderMode
    showGrid: bool
    showNeighborLines: bool
    plotStyle: PlotStyle
    
    RenderMap(map: Map)
    RenderSelection(selection: Selection)
    RenderToolPreview(preview: PreviewData)
    RenderOverlay(overlay: Overlay)
}

RenderMode enum {
    TERRAIN
    OWNERSHIP
    RESOURCES
    BUILDINGS
    ELEVATION
    CUSTOM
}

PlotStyle {
    fillColor: Color | ColorMapping
    strokeColor: Color
    strokeWidth: float
    opacity: float
    showLabels: bool
    labelContent: LabelContent
}

ColorMapping {
    mappingType: ColorMappingType
    colorScale: ColorScale
}

ColorMappingType enum {
    TERRAIN_TYPE
    OWNER
    RESOURCE_DENSITY
    BUILDING_COUNT
    POPULATION
    ATTRIBUTE_VALUE
}

LabelContent enum {
    NONE
    PLOT_ID
    TERRAIN_TYPE
    OWNER
    CUSTOM
}
```

### Editor Panels

#### Sidebar with Integrated PropertyPanel

The Sidebar is a unified left panel that contains all editor controls and displays detailed information about selected plots, allowing interactive editing of their properties.

**Sidebar Sections:**
1. **File Operations**: Generate, Load, Save map
2. **Tools**: Select and Paint tools
3. **Unit Editor**: Add, remove, and modify units on plots
4. **Cluster Editor**: Add, remove, and modify clusters on plots
5. **Simulation**: Step through simulation with statistics
6. **History**: Undo/Redo operations with edit count
7. **Selection**: Select All/Clear with selection count
8. **Terrain Types**: Grid of terrain type buttons for painting
9. **Map Statistics**: Overview of terrain distribution
10. **Plot Properties**: Detailed view of selected plot (integrated PropertyPanel)

**Unit Editor Section Features:**
- Dropdown to select unit category (Building or Movable)
- Grid of unit type buttons for quick placement
- Building units: Cave, Bonfire, Farm ground, Ranch ground, Fishing ground, Picking ground
- Movable units: Hunting team, Trade team, Warriors team
- Click on plot to add selected unit type
- Right-click on existing unit to remove or modify

**Cluster Editor Section Features:**
- Dropdown to select cluster category (Enlightened or Animal)
- Grid of cluster type buttons for quick placement
- Enlightened clusters: Human, Elf, Orc
- Animal clusters: Horse, Cattle, Chicken, Goat, Sheep
- Size input for new clusters
- Click on plot to add selected cluster type
- Right-click on existing cluster to remove or modify

**Plot Properties Section Features:**
- Displays comprehensive plot information when plots are selected
- Shows "No plot selected" message when no selection exists
- Displays a badge indicating the number of selected plots when multiple plots are selected
- All changes made through the properties section are tracked in the edit history (undo/redo support)
- Changes to terrain type apply to all selected plots simultaneously

**Displayed Information in Plot Properties:**
- **Basic Info**: Area, Perimeter, Neighbor count
- **Terrain**: Interactive dropdown to change terrain type, with visual color preview
- **Storage**: Detailed storage information with:
  - Resource name and type
  - Visual progress bar showing capacity utilization
  - Current amount / Maximum capacity
  - Resource efficiency ratings (Food, Tool, etc.) with values
- **Units**: List of units on the plot with type and owner information
  - Building units with processes and storage
  - Movable units with assigned workers
  - Edit and delete buttons for each unit
- **Clusters**: List of cluster groups with counts and details
  - Enlightened clusters with skills and relationships
  - Animal clusters with herd size
  - Edit and delete buttons for each cluster
- **Ownership**: Current owner or "Unowned"

**Editable Properties:**
- Terrain Type: Dropdown selector that applies changes to all selected plots
- Units: Add/Remove/Modify units directly from properties panel
- Clusters: Add/Remove/Modify clusters directly from properties panel

```
PropertyPanel {
    selectedPlots: []Plot
    
    // Display and edit properties of selected plots
    DisplayAttributes()
    EditAttribute(attribute: string, value: any)
    AddUnit()
    RemoveUnit(unitID: UnitID)
    ModifyUnit(unitID: UnitID, properties: UnitProperties)
    AddCluster()
    RemoveCluster(clusterID: ClusterID)
    ModifyCluster(clusterID: ClusterID, properties: ClusterProperties)
}

ToolsPanel {
    tools: []EditorTool
    activeTool: EditorTool?
    
    DisplayTools()
    ActivateTool(toolID: ToolID)
    ConfigureTool(toolID: ToolID, config: any)
}

LayersPanel {
    layers: []Layer
    
    ToggleLayer(layerID: LayerID)
    SetLayerOpacity(layerID: LayerID, opacity: float)
}

Layer {
    layerID: LayerID
    name: string
    visible: bool
    opacity: float
    renderFunction: (map: Map) -> void
}

HistoryPanel {
    history: EditHistory
    
    DisplayHistory()
    UndoToEdit(editID: EditID)
    RedoToEdit(editID: EditID)
}

ValidationPanel {
    validationResult: ValidationResult
    
    DisplayIssues()
    FilterIssues(severity: ValidationSeverity?)
    ApplySuggestedFix(issueID: IssueID)
    IgnoreIssue(issueID: IssueID)
}

MinimapPanel {
    map: Map
    viewport: Viewport
    
    Render()
    OnClick(point: Point)  // Pan main view to clicked location
}
```

## Keyboard Shortcuts

```
EditorShortcuts {
    // File operations
    "Ctrl+S": Save
    "Ctrl+Shift+S": SaveAs
    "Ctrl+O": Open
    "Ctrl+N": New
    
    // Edit operations
    "Ctrl+Z": Undo
    "Ctrl+Y" | "Ctrl+Shift+Z": Redo
    "Ctrl+A": SelectAll
    "Ctrl+D": DeselectAll
    "Delete": DeleteSelected
    
    // Tools
    "S": SelectTool
    "P": PaintTool
    "B": PlotSplitTool
    "M": PlotMergeTool
    "A": AttributeEditorTool
    "U": UnitEditorTool
    "C": ClusterEditorTool
    
    // View
    "Space+Drag": Pan
    "Ctrl+0": FitToMap
    "Ctrl++": ZoomIn
    "Ctrl+-": ZoomOut
    "G": ToggleGrid
    "N": ToggleNeighborLines
    
    // Selection
    "Ctrl+I": InvertSelection
    "E": ExpandSelectionToNeighbors
}
```

## Workflow Examples

### Workflow 1: Generate and Refine

```
1. Generate base map using MapGenerator
2. Open map in MapEditor
3. Review terrain distribution
4. Use PaintTool to adjust coastal areas
5. Use PlotSplitTool to subdivide large plots
6. Use AttributeEditorTool to add resources
7. Validate map
8. Export as JSON
```

### Workflow 2: Manual Creation

```
1. Create new empty map
2. Use PlotGeneratorTool to create initial plot grid
3. Use PlotMergeTool to create larger plots for oceans
4. Use PaintTool to set terrain types
5. Use AttributeEditorTool to place units
6. Use AttributeEditorTool to add starting clusters
7. Validate map
8. Export as JSON
```

### Workflow 3: Scenario Editor

```
1. Load existing map
2. Select plots by filter (e.g., all grassland plots)
3. Use BatchSetAttribute to assign ownership to players
4. Use AttributeEditorTool to place player starting cities
5. Use AttributeEditorTool to distribute resources
6. Add historical units and monuments
7. Set up initial species clusters
8. Validate map
9. Export as game scenario
```

## Plugin System

```
EditorPlugin interface {
    pluginID: PluginID
    name: string
    version: string
    
    OnLoad(editor: MapEditor)
    OnUnload(editor: MapEditor)
    GetTools() -> []EditorTool
    GetValidators() -> []Validator
    GetExporters() -> []Exporter
    GetImporters() -> []Importer
}

PluginManager {
    plugins: []EditorPlugin
    
    LoadPlugin(plugin: EditorPlugin)
    UnloadPlugin(pluginID: PluginID)
    GetPlugin(pluginID: PluginID) -> EditorPlugin?
}
```

## Performance Considerations

### Large Map Optimization

```
OptimizationStrategy {
    // Spatial indexing
    useSpatialIndex: bool
    spatialIndexType: SpatialIndexType  // QUADTREE, RTREE, GRID
    
    // Rendering optimization
    useViewportCulling: bool
    levelOfDetail: LevelOfDetailConfig
    
    // Edit optimization
    batchSimilarEdits: bool
    deferredValidation: bool
    
    // Memory management
    maxHistorySize: int
    compressHistoryItems: bool
}

SpatialIndexType enum {
    QUADTREE
    RTREE
    GRID
}

LevelOfDetailConfig {
    minPlotScreenSize: float  // Hide plots smaller than this
    simplifyGeometry: bool
    simplificationTolerance: float
}
```

### Viewport Culling

```
ViewportCuller {
    viewport: Viewport
    spatialIndex: SpatialIndex
    
    GetVisiblePlots() -> []PlotID {
        // Query spatial index for plots in viewport
        // Return only plots that intersect view frustum
    }
}
```

## Example Configurations

### Minimal Editor Config

```json
{
  "autoValidate": true,
  "maxHistorySize": 100,
  "autoSave": false,
  "snapToGrid": false,
  "showNeighborConnections": false,
  "highlightInvalidPlots": true
}
```

### Power User Config

```json
{
  "autoValidate": false,
  "maxHistorySize": 1000,
  "autoSave": true,
  "autoSaveInterval": 300,
  "snapToGrid": true,
  "gridSize": 5.0,
  "showNeighborConnections": true,
  "highlightInvalidPlots": true,
  "optimization": {
    "useSpatialIndex": true,
    "spatialIndexType": "QUADTREE",
    "useViewportCulling": true,
    "levelOfDetail": {
      "minPlotScreenSize": 2.0,
      "simplifyGeometry": true,
      "simplificationTolerance": 0.5
    }
  }
}
```

## Future Enhancements

1. **Collaborative Editing**: Multiple users editing the same map simultaneously
2. **AI-Assisted Editing**: Suggest terrain distributions and plot layouts
3. **Procedural Tools**: More sophisticated generation tools for rivers, mountains, etc.
4. **Animation Timeline**: Preview how map changes over time in-game
5. **Map Templates**: Pre-built map templates for common scenarios
6. **Advanced Filters**: Complex filtering and selection based on multiple criteria
7. **Script Recording**: Record edit sequences as replayable scripts
8. **3D Visualization**: View maps in 3D with elevation rendering
9. **Version Control**: Built-in versioning system for maps
10. **Terrain Painting**: Advanced terrain blending and transition tools
