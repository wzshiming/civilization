# Maps Editor

See [000.definition.md](000.definition.md) for base type definitions, [001.maps.md](001.maps.md) for map structure, and [002.maps-generator.md](002.maps-generator.md) for map generation.

## Overview

This document defines the map editor system that enables interactive creation, modification, and customization of game maps. The editor provides both a programmatic API and a user interface for manipulating maps created by the map generator or building them from scratch.

## Additional ID Types

Editor-specific ID types extending the base definitions:

```
EditID: UUID          // Unique identifier for an edit operation
ToolID: UUID          // Unique identifier for an editor tool
ValidatorID: UUID     // Unique identifier for a validator
IssueID: UUID         // Unique identifier for a validation issue
FormatID: string      // Identifier for export/import format
LayerID: UUID         // Unique identifier for a UI layer
PluginID: string      // Unique identifier for an editor plugin
```

## Design Goals

1. **Interactive Editing**: Provide real-time visual feedback for map modifications
2. **Non-Destructive**: Support undo/redo and preserve map history
3. **Validation**: Ensure map integrity and valid relationships between elements
4. **Flexible Workflow**: Support both automated generation with manual tweaks and complete manual creation
5. **Export/Import**: Enable saving and loading maps in various formats
6. **Extensible Tools**: Provide a plugin-based system for custom editing tools
7. **Performance**: Handle large maps (10,000+ plots) with smooth interaction

## Editor Architecture

```
MapEditor {
    map: Map
    history: EditHistory
    selection: Selection
    tools: []EditorTool
    validators: []Validator
    config: EditorConfig
    
    // Core operations
    ApplyEdit(edit: Edit) -> Result
    Undo() -> Result
    Redo() -> Result
    Validate() -> ValidationResult
    Save(format: ExportFormat) -> Result
    Load(source: string) -> Result
}

EditorConfig {
    autoValidate: bool
    maxHistorySize: int
    autoSave: bool
    autoSaveInterval: int  // seconds
    snapToGrid: bool
    gridSize: float
    showNeighborConnections: bool
    highlightInvalidPlots: bool
}
```

## Edit History System

```
EditHistory {
    undoStack: []Edit
    redoStack: []Edit
    maxSize: int
    
    Push(edit: Edit)
    Undo() -> Edit?
    Redo() -> Edit?
    Clear()
}

Edit {
    editID: EditID
    timestamp: int
    editType: EditType
    previousState: any
    newState: any
    affectedPlots: []PlotID
    
    Apply(map: Map) -> Result
    Revert(map: Map) -> Result
}

EditType enum {
    TERRAIN_CHANGE
    PLOT_SPLIT
    PLOT_MERGE
    PLOT_CREATE
    PLOT_DELETE
    NEIGHBOR_ADD
    NEIGHBOR_REMOVE
    ATTRIBUTE_CHANGE
    BUILDING_ADD
    BUILDING_REMOVE
    SPECIES_ADD
    SPECIES_REMOVE
    RESOURCE_CHANGE
    BATCH_EDIT
}
```

## Selection System

```
Selection {
    selectedPlots: []PlotID
    selectionMode: SelectionMode
    filterCriteria: FilterCriteria?
    
    Add(plotID: PlotID)
    Remove(plotID: PlotID)
    Clear()
    SelectAll()
    SelectByFilter(criteria: FilterCriteria)
    Invert()
    ExpandToNeighbors(depth: int)
    GetBoundingBox() -> BoundingBox
}

SelectionMode enum {
    SINGLE      // Only one plot at a time
    MULTIPLE    // Multiple individual plots
    REGION      // Contiguous region
    PAINT       // Brush-based selection
}

FilterCriteria {
    terrainTypes: []TerrainTypeID?
    hasBuildings: bool?
    buildingTypes: []BuildingTypeID?
    minArea: float?
    maxArea: float?
    ownerPlayerID: PlayerID?
    hasResources: bool?
    resourceTypes: []ResourceTypeID?
    customPredicate: (plot: Plot) -> bool
}

BoundingBox {
    minX: float
    minY: float
    maxX: float
    maxY: float
}
```

## Editor Tools

```
EditorTool interface {
    toolID: ToolID
    name: string
    description: string
    icon: string
    hotkey: string?
    
    OnActivate(editor: MapEditor)
    OnDeactivate(editor: MapEditor)
    OnMouseDown(point: Point, editor: MapEditor) -> ToolResult
    OnMouseMove(point: Point, editor: MapEditor) -> ToolResult
    OnMouseUp(point: Point, editor: MapEditor) -> ToolResult
    OnKeyPress(key: string, editor: MapEditor) -> ToolResult
}

ToolResult {
    editsApplied: []Edit
    cursorStyle: CursorStyle
    preview: PreviewData?
}
```

### Built-in Tools

#### SelectTool
```
SelectTool implements EditorTool {
    selectionMode: SelectionMode
    
    // Click to select single plot
    // Shift+Click to add to selection
    // Ctrl+Click to remove from selection
    // Drag to select region
}
```

#### PaintTool
```
PaintTool implements EditorTool {
    brushSize: float
    brushShape: BrushShape
    paintAction: PaintAction
    
    // Paint terrain types
    // Paint attributes
    // Smooth/blend terrain boundaries
}

BrushShape enum {
    CIRCLE
    SQUARE
    CUSTOM
}

PaintAction {
    actionType: PaintActionType
    value: any
}

PaintActionType enum {
    SET_TERRAIN
    SET_ATTRIBUTE
    ADD_RESOURCE
    REMOVE_RESOURCE
    SMOOTH_TERRAIN
}
```

#### PlotSplitTool
```
PlotSplitTool implements EditorTool {
    splitLine: Line?
    
    // Click and drag to draw line splitting plot
    // Generates new plot boundaries along line
    // Updates neighbor relationships
}
```

#### PlotMergeTool
```
PlotMergeTool implements EditorTool {
    // Click first plot, then neighboring plot
    // Merges two adjacent plots into one
    // Combines attributes based on merge strategy
    
    mergeStrategy: MergeStrategy
}

MergeStrategy {
    terrainResolution: TerrainResolutionType
    attributeResolution: AttributeResolutionType
}

TerrainResolutionType enum {
    USE_FIRST
    USE_SECOND
    USE_LARGER_AREA
}

AttributeResolutionType enum {
    COMBINE     // Sum/merge attributes
    USE_FIRST
    USE_SECOND
    AVERAGE
}
```

#### PlotGeneratorTool
```
PlotGeneratorTool implements EditorTool {
    regionConfig: RegionGeneratorConfig
    
    // Select region and generate new plots within it
    // Useful for regenerating specific areas
}

RegionGeneratorConfig {
    plotCount: int
    generationMethod: GenerationMethod
    terrainConfig: TerrainConfig?
    preserveBoundary: bool
}

GenerationMethod enum {
    VORONOI
    GRID
    HEXAGONAL
    RANDOM
}
```

#### AttributeEditorTool
```
AttributeEditorTool implements EditorTool {
    attributeType: AttributeType
    
    // Double-click plot to open attribute editor panel
    // Edit all plot attributes interactively
}
```

#### TerrainSmoothTool
```
TerrainSmoothTool implements EditorTool {
    smoothingStrength: float  // 0.0 to 1.0
    smoothingRadius: int      // neighbor depth
    
    // Click plot to smooth terrain transitions
    // Makes terrain changes more gradual
}
```

## Editing Operations

### Terrain Editing

```
SetTerrainType(plotIDs: []PlotID, terrainTypeID: TerrainTypeID) -> Edit
GetTerrainType(plotID: PlotID) -> TerrainTypeID
BatchSetTerrain(assignments: map[PlotID]TerrainTypeID) -> Edit
```

### Plot Manipulation

```
SplitPlot(plotID: PlotID, splitLine: Line) -> Edit {
    // 1. Calculate intersection points of line with plot boundary
    // 2. Create two new plot geometries
    // 3. Distribute attributes between new plots
    // 4. Update neighbor relationships
    // 5. Return edit containing old plot state and two new plots
}

MergePlots(plotID1: PlotID, plotID2: PlotID, strategy: MergeStrategy) -> Edit {
    // 1. Validate plots are neighbors
    // 2. Combine geometries (union of polygons)
    // 3. Merge attributes according to strategy
    // 4. Update neighbor relationships
    // 5. Return edit containing both old plots and merged plot
}

CreatePlot(vertices: []Point, attributes: PlotAttributes) -> Edit
DeletePlot(plotID: PlotID) -> Edit
ModifyPlotBoundary(plotID: PlotID, newVertices: []Point) -> Edit
```

### Attribute Editing

```
SetPlotAttribute(plotID: PlotID, attribute: string, value: any) -> Edit
BatchSetAttribute(plotIDs: []PlotID, attribute: string, value: any) -> Edit

// Specific attribute editors
SetOwner(plotIDs: []PlotID, playerID: PlayerID?) -> Edit
AddBuilding(plotID: PlotID, building: Building) -> Edit
RemoveBuilding(plotID: PlotID, buildingID: BuildingID) -> Edit
AddSpecies(plotID: PlotID, species: Species) -> Edit
RemoveSpecies(plotID: PlotID, speciesID: SpeciesID) -> Edit
UpdateStorage(plotID: PlotID, storageChanges: []StorageType) -> Edit
```

### Neighbor Editing

```
AddNeighbor(plotID1: PlotID, plotID2: PlotID) -> Edit
RemoveNeighbor(plotID1: PlotID, plotID2: PlotID) -> Edit
RecalculateNeighbors(plotIDs: []PlotID) -> Edit
AutoFixNeighbors() -> Edit {
    // Automatically detect and fix neighbor relationships
    // Based on geometric adjacency
}
```

### Batch Operations

```
BatchEdit {
    edits: []Edit
    description: string
    
    // Combines multiple edits into single undo/redo unit
}

ApplyBatchEdit(batch: BatchEdit) -> Result
```

## Validation System

```
Validator interface {
    validatorID: ValidatorID
    name: string
    severity: ValidationSeverity
    
    Validate(map: Map) -> []ValidationIssue
}

ValidationSeverity enum {
    ERROR      // Must be fixed before save
    WARNING    // Should be reviewed
    INFO       // Informational only
}

ValidationIssue {
    issueID: IssueID
    validatorID: ValidatorID
    severity: ValidationSeverity
    message: string
    affectedPlots: []PlotID
    suggestedFix: Edit?
}

ValidationResult {
    isValid: bool
    issues: []ValidationIssue
    errorCount: int
    warningCount: int
    infoCount: int
}
```

### Built-in Validators

```
NeighborConsistencyValidator {
    // Ensures neighbor relationships are bidirectional
    // If A neighbors B, then B must neighbor A
}

GeometryValidator {
    // Ensures plot geometries are valid
    // No self-intersecting polygons
    // No zero-area plots
    // No duplicate vertices
}

AttributeValidator {
    // Ensures required attributes are present
    // Validates attribute value ranges
    // Checks for orphaned references
}

ResourceValidator {
    // Ensures resources are valid for terrain type
    // Checks storage capacity constraints
}

NeighborGeometryValidator {
    // Ensures declared neighbors actually share edges
    // Detects missing neighbor relationships
}
```

## Export/Import System

```
ExportFormat enum {
    JSON
    GEOJSON
    SVG
    PNG
    CUSTOM
}

ImportFormat enum {
    JSON
    GEOJSON
    SHAPEFILE
    CUSTOM
}

Exporter interface {
    formatID: FormatID
    extension: string
    
    Export(map: Map, options: ExportOptions) -> Result
}

Importer interface {
    formatID: FormatID
    supportedExtensions: []string
    
    Import(source: string, options: ImportOptions) -> Map
}

ExportOptions {
    includeGeneratedData: bool
    prettyPrint: bool
    compression: CompressionType?
    imageResolution: int?  // For PNG/image exports
    customSettings: map[string]any
}

ImportOptions {
    validateOnImport: bool
    autoFixIssues: bool
    mergeStrategy: MergeStrategy?  // For importing into existing map
    customSettings: map[string]any
}
```

### JSON Export Format

```json
{
  "version": "1.0.0",
  "metadata": {
    "created": "2024-01-15T08:00:00Z",
    "modified": "2024-01-15T09:30:00Z",
    "creator": "MapEditor v1.0",
    "description": "Custom edited civilization map"
  },
  "map": {
    "plots": [...],
    "speciesTypes": [...],
    "resourceTypes": [...],
    "buildingTypes": [...],
    "terrainTypes": [...],
    "skillTypes": [...],
    "religions": [...],
    "cultures": [...]
  },
  "editorData": {
    "snapToGrid": true,
    "gridSize": 10.0,
    "lastEditTimestamp": 1734512400
  }
}
```

### GeoJSON Export Format

```json
{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "geometry": {
        "type": "Polygon",
        "coordinates": [[...]]
      },
      "properties": {
        "plotID": "uuid",
        "terrainType": "grassland",
        "owner": "player1",
        "buildings": [...],
        "resources": [...]
      }
    }
  ]
}
```

## User Interface Components

### Editor View

```
EditorView {
    viewport: Viewport
    renderer: Renderer
    eventHandler: EventHandler
    toolManager: ToolManager
    
    Render()
    HandleEvent(event: Event)
}

Viewport {
    centerX: float
    centerY: float
    zoom: float
    rotation: float
    
    Pan(deltaX: float, deltaY: float)
    Zoom(factor: float, centerPoint: Point?)
    Rotate(degrees: float)
    FitToMap()
    FocusOnPlots(plotIDs: []PlotID)
}

Renderer {
    canvas: Canvas
    renderMode: RenderMode
    showGrid: bool
    showNeighborLines: bool
    plotStyle: PlotStyle
    
    RenderMap(map: Map)
    RenderSelection(selection: Selection)
    RenderToolPreview(preview: PreviewData)
    RenderOverlay(overlay: Overlay)
}

RenderMode enum {
    TERRAIN
    OWNERSHIP
    RESOURCES
    BUILDINGS
    ELEVATION
    CUSTOM
}

PlotStyle {
    fillColor: Color | ColorMapping
    strokeColor: Color
    strokeWidth: float
    opacity: float
    showLabels: bool
    labelContent: LabelContent
}

ColorMapping {
    mappingType: ColorMappingType
    colorScale: ColorScale
}

ColorMappingType enum {
    TERRAIN_TYPE
    OWNER
    RESOURCE_DENSITY
    BUILDING_COUNT
    POPULATION
    ATTRIBUTE_VALUE
}

LabelContent enum {
    NONE
    PLOT_ID
    TERRAIN_TYPE
    OWNER
    CUSTOM
}
```

### Editor Panels

#### Sidecar (PropertyPanel Implementation)

The Sidecar is a side panel that displays detailed information about selected plots and allows interactive editing of their properties.

**Features:**
- Displays comprehensive plot information when plots are selected
- Shows "No plot selected" message when no selection exists
- Displays a badge indicating the number of selected plots when multiple plots are selected
- All changes made through the Sidecar are tracked in the edit history (undo/redo support)
- Changes to terrain type apply to all selected plots simultaneously

**Displayed Information:**
- **Basic Information**: Plot ID, Area, Perimeter, Center coordinates
- **Terrain**: Interactive dropdown to change terrain type, with visual preview of the selected terrain
- **Neighbors**: Count and list of neighboring plot IDs (first 5 shown, with count of additional neighbors)
- **Ownership**: Current owner (or "Unowned" if no owner)
- **Buildings**: Count and list of buildings on the plot
- **Species**: Count and list of species on the plot
- **Storage**: Count and list of stored resources
- **Populations**: Count and list of population groups

**Editable Properties:**
- Terrain Type: Dropdown selector that applies changes to all selected plots

```
PropertyPanel {
    selectedPlots: []Plot
    
    // Display and edit properties of selected plots
    DisplayAttributes()
    EditAttribute(attribute: string, value: any)
    AddBuilding()
    RemoveBuilding(buildingID: BuildingID)
    AddSpecies()
    RemoveSpecies(speciesID: SpeciesID)
}

ToolsPanel {
    tools: []EditorTool
    activeTool: EditorTool?
    
    DisplayTools()
    ActivateTool(toolID: ToolID)
    ConfigureTool(toolID: ToolID, config: any)
}

LayersPanel {
    layers: []Layer
    
    ToggleLayer(layerID: LayerID)
    SetLayerOpacity(layerID: LayerID, opacity: float)
}

Layer {
    layerID: LayerID
    name: string
    visible: bool
    opacity: float
    renderFunction: (map: Map) -> void
}

HistoryPanel {
    history: EditHistory
    
    DisplayHistory()
    UndoToEdit(editID: EditID)
    RedoToEdit(editID: EditID)
}

ValidationPanel {
    validationResult: ValidationResult
    
    DisplayIssues()
    FilterIssues(severity: ValidationSeverity?)
    ApplySuggestedFix(issueID: IssueID)
    IgnoreIssue(issueID: IssueID)
}

MinimapPanel {
    map: Map
    viewport: Viewport
    
    Render()
    OnClick(point: Point)  // Pan main view to clicked location
}
```

## Keyboard Shortcuts

```
EditorShortcuts {
    // File operations
    "Ctrl+S": Save
    "Ctrl+Shift+S": SaveAs
    "Ctrl+O": Open
    "Ctrl+N": New
    
    // Edit operations
    "Ctrl+Z": Undo
    "Ctrl+Y" | "Ctrl+Shift+Z": Redo
    "Ctrl+A": SelectAll
    "Ctrl+D": DeselectAll
    "Delete": DeleteSelected
    
    // Tools
    "S": SelectTool
    "P": PaintTool
    "B": PlotSplitTool
    "M": PlotMergeTool
    "A": AttributeEditorTool
    
    // View
    "Space+Drag": Pan
    "Ctrl+0": FitToMap
    "Ctrl++": ZoomIn
    "Ctrl+-": ZoomOut
    "G": ToggleGrid
    "N": ToggleNeighborLines
    
    // Selection
    "Ctrl+I": InvertSelection
    "E": ExpandSelectionToNeighbors
}
```

## Workflow Examples

### Workflow 1: Generate and Refine

```
1. Generate base map using MapGenerator
2. Open map in MapEditor
3. Review terrain distribution
4. Use PaintTool to adjust coastal areas
5. Use PlotSplitTool to subdivide large plots
6. Use AttributeEditorTool to add resources
7. Validate map
8. Export as JSON
```

### Workflow 2: Manual Creation

```
1. Create new empty map
2. Use PlotGeneratorTool to create initial plot grid
3. Use PlotMergeTool to create larger plots for oceans
4. Use PaintTool to set terrain types
5. Use AttributeEditorTool to place buildings
6. Use AttributeEditorTool to add starting populations
7. Validate map
8. Export as JSON
```

### Workflow 3: Scenario Editor

```
1. Load existing map
2. Select plots by filter (e.g., all grassland plots)
3. Use BatchSetAttribute to assign ownership to players
4. Use AttributeEditorTool to place player starting cities
5. Use AttributeEditorTool to distribute resources
6. Add historical buildings and monuments
7. Set up initial species populations
8. Validate map
9. Export as game scenario
```

## Plugin System

```
EditorPlugin interface {
    pluginID: PluginID
    name: string
    version: string
    
    OnLoad(editor: MapEditor)
    OnUnload(editor: MapEditor)
    GetTools() -> []EditorTool
    GetValidators() -> []Validator
    GetExporters() -> []Exporter
    GetImporters() -> []Importer
}

PluginManager {
    plugins: []EditorPlugin
    
    LoadPlugin(plugin: EditorPlugin)
    UnloadPlugin(pluginID: PluginID)
    GetPlugin(pluginID: PluginID) -> EditorPlugin?
}
```

## Performance Considerations

### Large Map Optimization

```
OptimizationStrategy {
    // Spatial indexing
    useSpatialIndex: bool
    spatialIndexType: SpatialIndexType  // QUADTREE, RTREE, GRID
    
    // Rendering optimization
    useViewportCulling: bool
    levelOfDetail: LevelOfDetailConfig
    
    // Edit optimization
    batchSimilarEdits: bool
    deferredValidation: bool
    
    // Memory management
    maxHistorySize: int
    compressHistoryItems: bool
}

SpatialIndexType enum {
    QUADTREE
    RTREE
    GRID
}

LevelOfDetailConfig {
    minPlotScreenSize: float  // Hide plots smaller than this
    simplifyGeometry: bool
    simplificationTolerance: float
}
```

### Viewport Culling

```
ViewportCuller {
    viewport: Viewport
    spatialIndex: SpatialIndex
    
    GetVisiblePlots() -> []PlotID {
        // Query spatial index for plots in viewport
        // Return only plots that intersect view frustum
    }
}
```

## Example Configurations

### Minimal Editor Config

```json
{
  "autoValidate": true,
  "maxHistorySize": 100,
  "autoSave": false,
  "snapToGrid": false,
  "showNeighborConnections": false,
  "highlightInvalidPlots": true
}
```

### Power User Config

```json
{
  "autoValidate": false,
  "maxHistorySize": 1000,
  "autoSave": true,
  "autoSaveInterval": 300,
  "snapToGrid": true,
  "gridSize": 5.0,
  "showNeighborConnections": true,
  "highlightInvalidPlots": true,
  "optimization": {
    "useSpatialIndex": true,
    "spatialIndexType": "QUADTREE",
    "useViewportCulling": true,
    "levelOfDetail": {
      "minPlotScreenSize": 2.0,
      "simplifyGeometry": true,
      "simplificationTolerance": 0.5
    }
  }
}
```

## Future Enhancements

1. **Collaborative Editing**: Multiple users editing the same map simultaneously
2. **AI-Assisted Editing**: Suggest terrain distributions and plot layouts
3. **Procedural Tools**: More sophisticated generation tools for rivers, mountains, etc.
4. **Animation Timeline**: Preview how map changes over time in-game
5. **Map Templates**: Pre-built map templates for common scenarios
6. **Advanced Filters**: Complex filtering and selection based on multiple criteria
7. **Script Recording**: Record edit sequences as replayable scripts
8. **3D Visualization**: View maps in 3D with elevation rendering
9. **Version Control**: Built-in versioning system for maps
10. **Terrain Painting**: Advanced terrain blending and transition tools
