# Maps Generator

See [000.definition.md](000.definition.md) for base type definitions and [001.maps.md](001.maps.md) for map structure.

## Overview

This document defines the map generator system responsible for creating game worlds with irregular plot shapes, dynamic attributes, and configurable terrain generation. The generator transforms configuration parameters into fully initialized maps with interconnected plots, terrain features, and resource distributions.

## Design Goals

1. **Irregular Plot Shapes**: Generate non-uniform, natural-looking plots using Voronoi tessellation
2. **Neighbor Relationships**: Maintain explicit adjacency information between plots
3. **Flexible Projections**: Support flat, cylindrical, and spherical projections with edge wrapping
4. **Configurable Terrain**: Allow control over ocean percentage, continent distribution, and climate zones
5. **Extensible Attributes**: Support dynamic addition of plot attributes (temperature, altitude, humidity, resources, etc.)
6. **Deterministic Generation**: Use seed-based random generation for reproducibility

## Generator Architecture

```
MapGenerator {
    config: MapConfig
    random: RandomGenerator
    
    Generate() -> Map
    GeneratePlots() -> []Plot
    GenerateNeighbors([]Plot) -> void
    GenerateTerrain([]Plot) -> void
    GenerateAttributes([]Plot) -> void
    GenerateResources([]Plot) -> void
}

RandomGenerator {
    seed: int
    
    NextFloat() -> float
    NextInt(max: int) -> int
    NextGaussian(mean: float, stddev: float) -> float
}
```

## Generation Pipeline

The map generation follows a multi-phase pipeline:

### Phase 1: Plot Generation

**Algorithm**: Voronoi Tessellation with Lloyd's Relaxation

```
PlotGenerationPhase {
    config: MapConfig
    
    Execute() -> []Plot {
        // 1. Generate initial seed points
        seedPoints = GenerateRandomPoints(config.plotCount, config.dimensions)
        
        // 2. Apply Lloyd's relaxation for better distribution
        for i in 0..config.relaxationSteps {
            seedPoints = RelaxPoints(seedPoints)
        }
        
        // 3. Compute Voronoi diagram
        voronoi = ComputeVoronoi(seedPoints, config.dimensions)
        
        // 4. Handle projection wrapping
        if config.projection.wrapHorizontal || config.projection.wrapVertical {
            voronoi = ApplyWrapping(voronoi, config.projection)
        }
        
        // 5. Apply pole scaling for spherical projections
        if config.projection.poleScaling != 1.0 {
            voronoi = ApplyPoleScaling(voronoi, config.projection.poleScaling)
        }
        
        // 6. Convert to Plot objects
        return ConvertToPlots(voronoi)
    }
}
```

**Plot Wrapping**: For wrapped edges, the Voronoi computation considers mirrored points beyond boundaries to ensure proper edge connectivity.

**Pole Scaling**: Plots near y=0 and y=height are scaled by `poleScaling` factor to simulate spherical projection distortion, creating larger polar regions.

### Phase 2: Neighbor Calculation

**Algorithm**: Voronoi Edge Analysis

```
NeighborCalculationPhase {
    Execute(plots: []Plot) -> void {
        for each plot in plots {
            plot.plotAttributes.neighborPlots = []
            
            // Find plots sharing edges
            for each otherPlot in plots {
                if plot == otherPlot {
                    continue
                }
                
                if SharesEdge(plot.vertices, otherPlot.vertices) {
                    plot.plotAttributes.neighborPlots.append(otherPlot.plotID)
                }
            }
        }
    }
    
    SharesEdge(vertices1: []Point, vertices2: []Point) -> bool {
        // Check if any edge from vertices1 matches an edge from vertices2
        // Account for floating point precision
        sharedVertices = 0
        for v1 in vertices1 {
            for v2 in vertices2 {
                if Distance(v1, v2) < epsilon {
                    sharedVertices++
                    break
                }
            }
        }
        return sharedVertices >= 2
    }
}
```

**Wrapping Consideration**: For wrapped edges, neighbor relationships extend across boundaries, connecting left-right or top-bottom edge plots.

### Phase 3: Terrain Generation

**Algorithm**: Multi-Octave Perlin Noise with Erosion Simulation

```
TerrainGenerationPhase {
    config: MapConfig
    
    Execute(plots: []Plot) -> void {
        // 1. Generate base elevation using Perlin noise
        elevationMap = GenerateElevationMap(config)
        
        // 2. Identify ocean plots based on elevation threshold
        oceanThreshold = CalculateOceanThreshold(elevationMap, config.terrain.oceanPercentage)
        
        for each plot in plots {
            elevation = SampleElevation(elevationMap, plot.center)
            
            if elevation < oceanThreshold {
                plot.plotAttributes.terrainType = OceanTerrainTypeID
            } else {
                // Assign land terrain based on elevation and climate
                plot.plotAttributes.terrainType = DetermineLandTerrain(elevation, plot)
            }
        }
        
        // 3. Apply coastal adjustments
        SmoothCoastlines(plots, config.terrain.coastalRoughness)
        
        // 4. Create continents and islands
        ApplyContinentDistribution(plots, config.terrain)
    }
}

GenerateElevationMap(config: MapConfig) -> NoiseMap {
    noise = PerlinNoise(seed: config.randomSeed)
    
    elevationMap = new NoiseMap(config.dimensions)
    
    // Multiple octaves for natural appearance
    for x, y in dimensions {
        value = 0.0
        amplitude = 1.0
        frequency = 1.0
        
        for octave in 0..4 {
            value += noise.Sample(x * frequency, y * frequency) * amplitude
            amplitude *= 0.5
            frequency *= 2.0
        }
        
        elevationMap.Set(x, y, value)
    }
    
    return elevationMap
}
```

### Phase 4: Attribute Generation

**Dynamic Attribute System**: Attributes are generated based on terrain, position, and neighboring plots.

```
AttributeGenerationPhase {
    Execute(plots: []Plot) -> void {
        GenerateAltitude(plots)
        GenerateTemperature(plots)
        GenerateHumidity(plots)
        GenerateFertility(plots)
        // Additional attributes can be added dynamically
    }
}

GenerateTemperature(plots: []Plot) -> void {
    for each plot in plots {
        // Base temperature from latitude (y-coordinate)
        latitudeFactor = abs(plot.center.y - config.dimensions.height/2) / (config.dimensions.height/2)
        baseTemp = MapRange(latitudeFactor, 0, 1, 30, -40) // °C
        
        // Altitude adjustment (-6.5°C per 1000m)
        altitude = plot.GetAttribute("altitude")
        altitudeAdjustment = -(altitude / 1000.0) * 6.5
        
        // Ocean proximity adjustment
        oceanDistance = CalculateOceanDistance(plot)
        oceanModeration = MapRange(oceanDistance, 0, maxDistance, 5, 0)
        
        temperature = baseTemp + altitudeAdjustment + oceanModeration + RandomNoise()
        plot.SetAttribute("temperature", temperature)
    }
}

GenerateHumidity(plots: []Plot) -> void {
    for each plot in plots {
        // Higher humidity near oceans and at equator
        oceanDistance = CalculateOceanDistance(plot)
        latitudeFactor = abs(plot.center.y - config.dimensions.height/2) / (config.dimensions.height/2)
        
        baseHumidity = MapRange(oceanDistance, 0, maxDistance, 0.9, 0.2)
        equatorBonus = (1.0 - latitudeFactor) * 0.2
        
        humidity = Clamp(baseHumidity + equatorBonus + RandomNoise(), 0.0, 1.0)
        plot.SetAttribute("humidity", humidity)
    }
}
```

### Phase 5: Resource Generation

```
ResourceGenerationPhase {
    config: MapConfig
    
    Execute(plots: []Plot) -> void {
        // Distribute resources based on terrain and attributes
        for each resourceType in config.resourceTypes {
            PlaceResources(plots, resourceType)
        }
    }
    
    PlaceResources(plots: []Plot, resourceType: ResourceType) -> void {
        // Calculate suitability score for each plot
        suitablePlots = []
        
        for each plot in plots {
            suitability = CalculateResourceSuitability(plot, resourceType)
            if suitability > threshold {
                suitablePlots.append({plot, suitability})
            }
        }
        
        // Place resources in clusters
        resourceCount = int(len(suitablePlots) * config.resourceDensity)
        clusters = SelectClusters(suitablePlots, resourceCount)
        
        for each cluster in clusters {
            amount = DetermineResourceAmount(cluster.plot, resourceType)
            cluster.plot.AddResource(resourceType, amount)
            
            // Spread to neighbors
            for neighborID in cluster.plot.plotAttributes.neighborPlots {
                if Random() < 0.3 {
                    neighborPlot = FindPlot(neighborID)
                    neighborPlot.AddResource(resourceType, amount * 0.5)
                }
            }
        }
    }
}
```

## Data Structures

### Extended Plot Attributes

```
PlotAttributes {
    // From 000.definition.md
    ownerPlayerID: PlayerID?
    terrainType: TerrainTypeID
    neighborPlots: []PlotID
    storages: []StorageType
    buildings: []Building
    species: []Species
    populations: []Population
    
    // Dynamic attributes (key-value store for extensibility)
    attributes: map[string]Attribute
}

Attribute {
    name: string
    value: float | int | string | bool
    lastUpdated: timestamp
    version: int
}

// Common attribute keys:
// - "altitude": float (meters)
// - "temperature": float (°C)
// - "humidity": float (0.0-1.0)
// - "fertility": float (0.0-1.0)
// - "rainfall": float (mm/year)
// - "resources.{resourceType}": float (quantity)
// - "biome": string (desert, forest, tundra, etc.)
```

### Extended Map Config

```
MapConfig {
    // From 001.maps.md
    plotCount: int
    dimensions: Dimensions
    projection: ProjectionConfig
    terrain: TerrainConfig
    resourceDensity: float
    climateVariance: float
    randomSeed: int
    relaxationSteps: int
    
    // Additional generator config
    generatorVersion: string
    attributeGenerators: []AttributeGeneratorConfig
}

AttributeGeneratorConfig {
    attributeName: string
    generatorType: string  // "noise", "gradient", "proximity", "custom"
    parameters: map[string]any
    enabled: bool
}
```

## Projection Types

### Flat Projection
```
ProjectionConfig {
    wrapHorizontal: false
    wrapVertical: false
    poleScaling: 1.0
}
```
- No edge wrapping
- Uniform plot sizes
- Suitable for regional maps

### Cylindrical Projection
```
ProjectionConfig {
    wrapHorizontal: true
    wrapVertical: false
    poleScaling: 1.0
}
```
- Left-right edges connect
- Top and bottom are boundaries
- Suitable for world maps without poles

### Spherical Projection
```
ProjectionConfig {
    wrapHorizontal: true
    wrapVertical: true
    poleScaling: 1.5  // Larger polar plots
}
```
- All edges wrap around
- Polar regions have larger plots (due to projection distortion)
- Best representation of planetary surface

## Performance Considerations

1. **Voronoi Computation**: O(n log n) with Fortune's algorithm
2. **Lloyd's Relaxation**: O(n * relaxationSteps)
3. **Neighbor Calculation**: O(n²) worst case, O(n) average with spatial hashing
4. **Attribute Generation**: O(n * attributeCount)
5. **Memory**: ~1KB per plot with full attributes

**Optimization Strategies**:
- Use spatial indexing (quadtree/grid) for neighbor searches
- Cache expensive calculations (ocean distance, climate zones)
- Generate attributes lazily when first accessed
- Support streaming generation for very large maps

## Extensibility

The generator is designed for easy extension:

### Adding New Attributes

```go
// Register new attribute generator
generator.RegisterAttributeGenerator("windSpeed", func(plot Plot, context GenerationContext) float {
    // Calculate wind speed based on latitude, temperature gradients, etc.
    latitude := plot.Center.Y / context.Config.Dimensions.Height
    baseWind := 5.0 + latitude * 10.0
    return baseWind + context.Random.NextGaussian(0, 2.0)
})
```

### Custom Terrain Algorithms

```go
// Override default terrain generator
generator.SetTerrainGenerator(func(plots []Plot, config MapConfig) {
    // Custom terrain generation logic
    // Could implement plate tectonics, erosion, etc.
})
```

### Post-Processing Hooks

```go
// Add post-generation processing
generator.AddPostProcessor(func(map Map) {
    // Validate, adjust, or enhance generated map
    // e.g., ensure starting positions, balance resources
})
```

## Example Configuration

```json
{
  "plotCount": 2000,
  "dimensions": {
    "width": 1000.0,
    "height": 600.0
  },
  "projection": {
    "wrapHorizontal": true,
    "wrapVertical": true,
    "poleScaling": 1.5
  },
  "terrain": {
    "oceanPercentage": 0.65,
    "continentCount": 4,
    "islandFrequency": 0.15,
    "coastalRoughness": 0.3
  },
  "resourceDensity": 0.08,
  "climateVariance": 0.2,
  "randomSeed": 42,
  "relaxationSteps": 3,
  "generatorVersion": "1.0.0",
  "attributeGenerators": [
    {
      "attributeName": "altitude",
      "generatorType": "noise",
      "parameters": {
        "octaves": 4,
        "persistence": 0.5,
        "lacunarity": 2.0
      },
      "enabled": true
    },
    {
      "attributeName": "temperature",
      "generatorType": "gradient",
      "parameters": {
        "equatorTemp": 30.0,
        "poleTemp": -40.0
      },
      "enabled": true
    }
  ]
}
```

## Future Enhancements

1. **Tectonic Simulation**: Model plate boundaries for realistic mountain ranges and ocean trenches
2. **River Generation**: Create river networks following elevation gradients
3. **Climate Zones**: Define distinct biomes based on temperature and humidity matrices
4. **Historical Generation**: Simulate geological time to create erosion patterns
5. **Performance**: Parallel generation phases for large maps (>10,000 plots)
6. **Validation**: Ensure playable maps (reachable continents, balanced resources)
7. **Previews**: Generate low-resolution previews for quick configuration testing
