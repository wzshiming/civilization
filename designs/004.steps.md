# Steps Logic

See [000.definition.md](000.definition.md) for base type definitions and [001.maps.md](001.maps.md) for map structure.

## Overview

This document defines the steps system that advances the simulation forward in time. Each step represents a discrete time unit (e.g., a day) during which plots execute their processes, consume and produce resources, and update their state.

## Design Goals

1. **Discrete Time Simulation**: Advance the game state in atomic steps
2. **Process Execution**: Execute all active processes in plots, units, and for species
3. **Resource Flow**: Handle resource consumption and production during each step
4. **Deterministic**: Same state + same step = same result
5. **Extensible**: Allow for future additions like population growth, diplomacy, etc.

## Step Types

```
StepResult {
    success: boolean
    processedPlots: number
    resourceChanges: ResourceChangeLog[]
    errors: StepError[]
}

ResourceChangeLog {
    plotID: PlotID
    resourceType: ResourceTypeID
    previousSize: number
    newSize: number
    source: string  // Description of what caused the change
}

StepError {
    plotID: PlotID
    message: string
    processName?: string
}
```

## Step Execution

```
StepExecutor {
    ExecuteStep(map: GameMap) -> StepResult
}
```

### Step Pipeline

The step execution follows a multi-phase pipeline:

1. **Process Execution Phase**: For each plot, execute terrain processes, unit processes, and species processes
2. **Resource Update Phase**: Apply all resource changes from executed processes
3. **Validation Phase**: Ensure no resources go negative, cap at storage capacity
4. **Result Compilation**: Collect all changes and return step result

## Process Execution

For each plot, processes are executed in the following order:

1. **Terrain Processes**: Natural processes from the terrain type (e.g., grass growth on plains)
2. **Unit Processes**: Production processes from units with workers
3. **Cluster Processes**: Consumption and production from clusters

### Resource Change Application

```
ApplyResourceChange(plot: Plot, change: ResourceChange) {
    // Find matching storage
    storage = plot.plotAttributes.storages.find(s => s.resourceType === change.resourceType)
    
    if (!storage) {
        // Create new storage if needed
        storage = { resourceType: change.resourceType, size: 0, capacity: Infinity }
        plot.plotAttributes.storages.push(storage)
    }
    
    // Apply change
    storage.size += change.size
    
    // Clamp to valid range
    storage.size = max(0, min(storage.size, storage.capacity))
}
```

## Convenience Functions

```
// Execute a single step on the entire map
ExecuteStep(map: GameMap) -> StepResult

// Execute multiple steps
ExecuteSteps(map: GameMap, count: number) -> StepResult[]
```

## Integration with Editor

The editor provides a "Step" button in the sidebar that:
1. Calls `ExecuteStep()` on the current map
2. Updates the map state with the result
3. Displays any errors or warnings from the step

## Example Usage

```typescript
// Execute one step
const result = executeStep(map);

if (result.success) {
    console.log(`Processed ${result.processedPlots} plots`);
    console.log(`${result.resourceChanges.length} resource changes`);
} else {
    console.error('Step failed:', result.errors);
}

// Execute multiple steps
const results = executeSteps(map, 10);
```
